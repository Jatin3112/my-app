# Sprint 1.2 — Razorpay Integration Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Enable Indian users to subscribe to Solo/Team/Agency plans via Razorpay (UPI/cards/netbanking), with upgrade/downgrade and cancellation support.

**Architecture:** Razorpay Subscriptions API with server-side plan creation, client-side checkout modal, and webhook-based payment confirmation. All payment state transitions happen via webhooks for reliability.

**Tech Stack:** Razorpay Node SDK, Next.js API routes, Drizzle ORM, Razorpay Checkout.js (CDN)

---

### Task 1: Install razorpay package + add env vars

**Files:**
- Modify: `package.json`
- Create: `.env.local` (add new vars)

**Step 1: Install razorpay SDK**

Run: `npm install razorpay`

**Step 2: Add env vars to .env.local**

Add these lines to `.env.local`:
```
RAZORPAY_KEY_ID=rzp_test_YOURKEY
RAZORPAY_KEY_SECRET=YOURSECRET
RAZORPAY_WEBHOOK_SECRET=YOURWEBHOOKSECRET
NEXT_PUBLIC_RAZORPAY_KEY_ID=rzp_test_YOURKEY
```

User must fill in their actual Razorpay test credentials.

**Step 3: Commit**

```bash
git add package.json package-lock.json
git commit -m "chore: install razorpay SDK"
```

---

### Task 2: Add razorpay_plan_id to plans schema + migrate

**Files:**
- Modify: `lib/db/schema.ts:128-141` — add column to plans table
- Test: `__tests__/lib/db/schema-razorpay.test.ts`

**Step 1: Add column to plans table**

In `lib/db/schema.ts`, add to the `plans` table definition after `is_active`:

```typescript
razorpay_plan_id: text("razorpay_plan_id"),
```

**Step 2: Generate and push migration**

Run: `npm run db:generate && npm run db:push`

**Step 3: Commit**

```bash
git add lib/db/schema.ts drizzle/
git commit -m "feat: add razorpay_plan_id column to plans table"
```

---

### Task 3: Create lib/payments/razorpay.ts — Razorpay client + helpers

**Files:**
- Create: `lib/payments/razorpay.ts`
- Test: `__tests__/lib/payments/razorpay.test.ts`

**Step 1: Write tests for razorpay helpers**

```typescript
// __tests__/lib/payments/razorpay.test.ts
import { describe, it, expect, vi, beforeEach } from "vitest";

vi.mock("razorpay", () => {
  return {
    default: vi.fn().mockImplementation(() => ({
      plans: { create: vi.fn(), all: vi.fn() },
      subscriptions: { create: vi.fn(), cancel: vi.fn(), update: vi.fn(), fetch: vi.fn() },
    })),
  };
});

import { verifyWebhookSignature } from "@/lib/payments/razorpay";
import crypto from "crypto";

describe("verifyWebhookSignature", () => {
  it("returns true for valid signature", () => {
    const body = '{"event":"payment.captured"}';
    const secret = "test_webhook_secret";
    const expected = crypto.createHmac("sha256", secret).update(body).digest("hex");
    expect(verifyWebhookSignature(body, expected, secret)).toBe(true);
  });

  it("returns false for invalid signature", () => {
    expect(verifyWebhookSignature("body", "bad_sig", "secret")).toBe(false);
  });
});
```

**Step 2: Run test — verify it fails**

Run: `npx vitest run __tests__/lib/payments/razorpay.test.ts`
Expected: FAIL — module not found

**Step 3: Implement lib/payments/razorpay.ts**

```typescript
import Razorpay from "razorpay";
import crypto from "crypto";

// ─── Client ───

let instance: InstanceType<typeof Razorpay> | null = null;

export function getRazorpay(): InstanceType<typeof Razorpay> {
  if (instance) return instance;
  const key_id = process.env.RAZORPAY_KEY_ID;
  const key_secret = process.env.RAZORPAY_KEY_SECRET;
  if (!key_id || !key_secret) {
    throw new Error("Missing RAZORPAY_KEY_ID or RAZORPAY_KEY_SECRET env vars");
  }
  instance = new Razorpay({ key_id, key_secret });
  return instance;
}

// ─── Webhook Verification ───

export function verifyWebhookSignature(
  body: string,
  signature: string,
  secret: string,
): boolean {
  const expected = crypto.createHmac("sha256", secret).update(body).digest("hex");
  try {
    return crypto.timingSafeEqual(Buffer.from(expected), Buffer.from(signature));
  } catch {
    return false;
  }
}

// ─── Plan Sync ───

export async function createRazorpayPlan(opts: {
  name: string;
  amount: number;       // in paise (INR * 100)
  currency: string;
  period: "monthly";
  interval: number;
}): Promise<string> {
  const rz = getRazorpay();
  const plan = await rz.plans.create({
    period: opts.period,
    interval: opts.interval,
    item: {
      name: opts.name,
      amount: opts.amount,
      currency: opts.currency,
    },
  });
  return plan.id;
}

// ─── Subscriptions ───

export async function createRazorpaySubscription(opts: {
  planId: string;
  totalCount: 12;          // 12 months default
  customerNotify: 0 | 1;
  notes?: Record<string, string>;
}): Promise<{ id: string; short_url: string }> {
  const rz = getRazorpay();
  const sub = await rz.subscriptions.create({
    plan_id: opts.planId,
    total_count: opts.totalCount,
    customer_notify: opts.customerNotify,
    notes: opts.notes ?? {},
  });
  return { id: sub.id, short_url: sub.short_url };
}

export async function cancelRazorpaySubscription(
  subscriptionId: string,
  cancelAtCycleEnd: boolean = true,
): Promise<void> {
  const rz = getRazorpay();
  await rz.subscriptions.cancel(subscriptionId, cancelAtCycleEnd);
}

export async function updateRazorpaySubscription(
  subscriptionId: string,
  newPlanId: string,
): Promise<void> {
  const rz = getRazorpay();
  await rz.subscriptions.update(subscriptionId, { plan_id: newPlanId });
}

export async function fetchRazorpaySubscription(subscriptionId: string) {
  const rz = getRazorpay();
  return rz.subscriptions.fetch(subscriptionId);
}
```

**Step 4: Run test — verify it passes**

Run: `npx vitest run __tests__/lib/payments/razorpay.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add lib/payments/razorpay.ts __tests__/lib/payments/razorpay.test.ts
git commit -m "feat: add Razorpay client library with webhook verification"
```

---

### Task 4: Update seed script to auto-create Razorpay plans

**Files:**
- Modify: `lib/db/seed-plans.ts`

**Step 1: Update seed script**

Add Razorpay plan creation after DB insert. The seed script checks if `RAZORPAY_KEY_ID` is set; if so, creates plans in Razorpay and stores the ID back in the DB.

Add to `lib/db/seed-plans.ts` after existing imports:

```typescript
import { eq } from "drizzle-orm";

// Optional: sync plans to Razorpay if credentials exist
async function syncToRazorpay(db: any, planRecord: any, planData: any) {
  if (!process.env.RAZORPAY_KEY_ID || !process.env.RAZORPAY_KEY_SECRET) {
    console.log("    Skipping Razorpay sync (no credentials)");
    return;
  }
  if (planRecord.razorpay_plan_id) {
    console.log(`    Razorpay plan already exists: ${planRecord.razorpay_plan_id}`);
    return;
  }

  const { createRazorpayPlan } = await import("../payments/razorpay");
  const rzPlanId = await createRazorpayPlan({
    name: planData.name,
    amount: planData.price_inr * 100, // paise
    currency: "INR",
    period: "monthly",
    interval: 1,
  });

  await db.update(plans).set({ razorpay_plan_id: rzPlanId }).where(eq(plans.id, planRecord.id));
  console.log(`    Synced to Razorpay: ${rzPlanId}`);
}
```

Call `syncToRazorpay` after each plan insert/find in the seed loop.

**Step 2: Run seed to test**

Run: `npm run db:seed`
Expected: Plans synced to Razorpay (or skipped if no credentials)

**Step 3: Commit**

```bash
git add lib/db/seed-plans.ts
git commit -m "feat: seed script auto-creates Razorpay plans via API"
```

---

### Task 5: Create /api/payments/razorpay/create-subscription route

**Files:**
- Create: `app/api/payments/razorpay/create-subscription/route.ts`
- Test: `__tests__/app/api/payments/razorpay/create-subscription.test.ts`

**Step 1: Write the test**

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";

vi.mock("@/lib/auth/auth-options", () => ({
  authOptions: {},
}));

vi.mock("next-auth", () => ({
  getServerSession: vi.fn(),
}));

vi.mock("@/lib/db", () => ({
  db: { query: { plans: { findFirst: vi.fn() } } },
}));

vi.mock("@/lib/api/subscriptions", () => ({
  getSubscription: vi.fn(),
}));

vi.mock("@/lib/payments/razorpay", () => ({
  createRazorpaySubscription: vi.fn(),
}));

import { getServerSession } from "next-auth";
import { db } from "@/lib/db";
import { createRazorpaySubscription } from "@/lib/payments/razorpay";
import { getSubscription } from "@/lib/api/subscriptions";

describe("POST /api/payments/razorpay/create-subscription", () => {
  beforeEach(() => vi.clearAllMocks());

  it("returns 401 when not authenticated", async () => {
    vi.mocked(getServerSession).mockResolvedValue(null);

    const { POST } = await import("@/app/api/payments/razorpay/create-subscription/route");
    const req = new Request("http://localhost/api/payments/razorpay/create-subscription", {
      method: "POST",
      body: JSON.stringify({ planSlug: "solo", workspaceId: "ws-1" }),
    });
    const res = await POST(req);
    expect(res.status).toBe(401);
  });

  it("returns 400 when plan not found", async () => {
    vi.mocked(getServerSession).mockResolvedValue({ user: { id: "u1", email: "a@b.com" } } as any);
    vi.mocked(db.query.plans.findFirst).mockResolvedValue(undefined);

    const { POST } = await import("@/app/api/payments/razorpay/create-subscription/route");
    const req = new Request("http://localhost/api/payments/razorpay/create-subscription", {
      method: "POST",
      body: JSON.stringify({ planSlug: "nonexistent", workspaceId: "ws-1" }),
    });
    const res = await POST(req);
    expect(res.status).toBe(400);
  });
});
```

**Step 2: Implement the route**

```typescript
// app/api/payments/razorpay/create-subscription/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth-options";
import { db } from "@/lib/db";
import { plans, subscriptions } from "@/lib/db/schema";
import { eq } from "drizzle-orm";
import { createRazorpaySubscription } from "@/lib/payments/razorpay";
import { getSubscription } from "@/lib/api/subscriptions";

export async function POST(req: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const body = await req.json();
  const { planSlug, workspaceId } = body;

  if (!planSlug || !workspaceId) {
    return NextResponse.json({ error: "planSlug and workspaceId required" }, { status: 400 });
  }

  // Find the plan
  const plan = await db.query.plans.findFirst({
    where: eq(plans.slug, planSlug),
  });

  if (!plan || !plan.razorpay_plan_id) {
    return NextResponse.json({ error: "Plan not found or not configured for payments" }, { status: 400 });
  }

  try {
    const userId = (session.user as any).id;

    // Create Razorpay subscription
    const rzSub = await createRazorpaySubscription({
      planId: plan.razorpay_plan_id,
      totalCount: 12,
      customerNotify: 1,
      notes: { workspace_id: workspaceId, user_id: userId, plan_slug: planSlug },
    });

    // Check if workspace already has a subscription
    const existingSub = await getSubscription(workspaceId);

    if (existingSub) {
      // Update existing subscription with Razorpay info
      await db.update(subscriptions)
        .set({
          plan_id: plan.id,
          payment_provider: "razorpay",
          provider_subscription_id: rzSub.id,
          updated_at: new Date(),
        })
        .where(eq(subscriptions.id, existingSub.id));
    } else {
      // Create new subscription record
      await db.insert(subscriptions).values({
        workspace_id: workspaceId,
        plan_id: plan.id,
        status: "pending",
        payment_provider: "razorpay",
        provider_subscription_id: rzSub.id,
      });
    }

    return NextResponse.json({
      subscriptionId: rzSub.id,
      shortUrl: rzSub.short_url,
    });
  } catch (error: any) {
    console.error("Razorpay create subscription error:", error);
    return NextResponse.json({ error: "Failed to create subscription" }, { status: 500 });
  }
}
```

**Step 3: Run test**

Run: `npx vitest run __tests__/app/api/payments/razorpay/create-subscription.test.ts`

**Step 4: Commit**

```bash
git add app/api/payments/razorpay/create-subscription/ __tests__/app/api/payments/razorpay/
git commit -m "feat: add Razorpay create-subscription API route"
```

---

### Task 6: Create /api/payments/razorpay/webhook route

**Files:**
- Create: `app/api/payments/razorpay/webhook/route.ts`
- Test: `__tests__/app/api/payments/razorpay/webhook.test.ts`

**Step 1: Write the test**

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import crypto from "crypto";

vi.mock("@/lib/payments/razorpay", () => ({
  verifyWebhookSignature: vi.fn(),
}));

vi.mock("@/lib/db", () => ({
  db: {
    update: vi.fn().mockReturnValue({ set: vi.fn().mockReturnValue({ where: vi.fn() }) }),
    insert: vi.fn().mockReturnValue({ values: vi.fn() }),
    query: { subscriptions: { findFirst: vi.fn() } },
  },
}));

import { verifyWebhookSignature } from "@/lib/payments/razorpay";

describe("POST /api/payments/razorpay/webhook", () => {
  beforeEach(() => vi.clearAllMocks());

  it("returns 400 for invalid signature", async () => {
    vi.mocked(verifyWebhookSignature).mockReturnValue(false);

    const { POST } = await import("@/app/api/payments/razorpay/webhook/route");
    const req = new Request("http://localhost/api/payments/razorpay/webhook", {
      method: "POST",
      body: '{"event":"subscription.activated"}',
      headers: { "x-razorpay-signature": "invalid" },
    });
    const res = await POST(req);
    expect(res.status).toBe(400);
  });

  it("returns 200 for valid signature", async () => {
    vi.mocked(verifyWebhookSignature).mockReturnValue(true);

    const { POST } = await import("@/app/api/payments/razorpay/webhook/route");
    const payload = JSON.stringify({
      event: "subscription.activated",
      payload: {
        subscription: {
          entity: {
            id: "sub_123",
            plan_id: "plan_123",
            current_start: 1700000000,
            current_end: 1702592000,
            notes: { workspace_id: "ws-1" },
          },
        },
      },
    });
    const req = new Request("http://localhost/api/payments/razorpay/webhook", {
      method: "POST",
      body: payload,
      headers: { "x-razorpay-signature": "valid" },
    });
    const res = await POST(req);
    expect(res.status).toBe(200);
  });
});
```

**Step 2: Implement the webhook route**

```typescript
// app/api/payments/razorpay/webhook/route.ts
import { NextRequest, NextResponse } from "next/server";
import { verifyWebhookSignature } from "@/lib/payments/razorpay";
import { db } from "@/lib/db";
import { subscriptions, paymentHistory } from "@/lib/db/schema";
import { eq } from "drizzle-orm";

export async function POST(req: NextRequest) {
  const body = await req.text();
  const signature = req.headers.get("x-razorpay-signature") ?? "";
  const secret = process.env.RAZORPAY_WEBHOOK_SECRET;

  if (!secret || !verifyWebhookSignature(body, signature, secret)) {
    return NextResponse.json({ error: "Invalid signature" }, { status: 400 });
  }

  const event = JSON.parse(body);
  const eventType = event.event;

  try {
    switch (eventType) {
      case "subscription.activated": {
        const rzSub = event.payload.subscription.entity;
        await db.update(subscriptions)
          .set({
            status: "active",
            current_period_start: new Date(rzSub.current_start * 1000),
            current_period_end: new Date(rzSub.current_end * 1000),
            updated_at: new Date(),
          })
          .where(eq(subscriptions.provider_subscription_id, rzSub.id));
        break;
      }

      case "subscription.charged": {
        const rzSub = event.payload.subscription.entity;
        const payment = event.payload.payment?.entity;
        // Update period dates
        await db.update(subscriptions)
          .set({
            current_period_start: new Date(rzSub.current_start * 1000),
            current_period_end: new Date(rzSub.current_end * 1000),
            updated_at: new Date(),
          })
          .where(eq(subscriptions.provider_subscription_id, rzSub.id));
        // Record payment
        if (payment) {
          const sub = await db.query.subscriptions.findFirst({
            where: eq(subscriptions.provider_subscription_id, rzSub.id),
          });
          if (sub) {
            await db.insert(paymentHistory).values({
              workspace_id: sub.workspace_id,
              subscription_id: sub.id,
              amount: payment.amount,
              currency: payment.currency?.toUpperCase() ?? "INR",
              provider: "razorpay",
              provider_payment_id: payment.id,
              status: "captured",
              description: `Subscription renewal`,
            });
          }
        }
        break;
      }

      case "subscription.cancelled": {
        const rzSub = event.payload.subscription.entity;
        await db.update(subscriptions)
          .set({
            status: "cancelled",
            cancel_at_period_end: true,
            updated_at: new Date(),
          })
          .where(eq(subscriptions.provider_subscription_id, rzSub.id));
        break;
      }

      case "payment.captured": {
        const payment = event.payload.payment.entity;
        const notes = payment.notes ?? {};
        if (notes.workspace_id) {
          const sub = await db.query.subscriptions.findFirst({
            where: eq(subscriptions.workspace_id, notes.workspace_id),
          });
          if (sub) {
            await db.insert(paymentHistory).values({
              workspace_id: notes.workspace_id,
              subscription_id: sub.id,
              amount: payment.amount,
              currency: payment.currency?.toUpperCase() ?? "INR",
              provider: "razorpay",
              provider_payment_id: payment.id,
              status: "captured",
              description: `Payment for ${notes.plan_slug ?? "subscription"}`,
            });
          }
        }
        break;
      }
    }

    return NextResponse.json({ status: "ok" });
  } catch (error) {
    console.error("Webhook processing error:", error);
    return NextResponse.json({ error: "Webhook processing failed" }, { status: 500 });
  }
}
```

**Step 3: Run tests**

Run: `npx vitest run __tests__/app/api/payments/razorpay/webhook.test.ts`

**Step 4: Commit**

```bash
git add app/api/payments/razorpay/webhook/ __tests__/app/api/payments/razorpay/
git commit -m "feat: add Razorpay webhook handler with signature verification"
```

---

### Task 7: Create components/billing/razorpay-checkout.tsx

**Files:**
- Create: `components/billing/razorpay-checkout.tsx`
- Test: `__tests__/components/billing/razorpay-checkout.test.tsx`

**Step 1: Implement the component**

```typescript
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { toast } from "sonner";

declare global {
  interface Window {
    Razorpay: any;
  }
}

type RazorpayCheckoutProps = {
  planSlug: string;
  planName: string;
  workspaceId: string;
  priceDisplay: string; // e.g., "₹499/mo"
  disabled?: boolean;
  variant?: "default" | "outline";
  onSuccess?: () => void;
};

function loadRazorpayScript(): Promise<boolean> {
  return new Promise((resolve) => {
    if (window.Razorpay) return resolve(true);
    const script = document.createElement("script");
    script.src = "https://checkout.razorpay.com/v1/checkout.js";
    script.onload = () => resolve(true);
    script.onerror = () => resolve(false);
    document.body.appendChild(script);
  });
}

export function RazorpayCheckout({
  planSlug,
  planName,
  workspaceId,
  priceDisplay,
  disabled = false,
  variant = "default",
  onSuccess,
}: RazorpayCheckoutProps) {
  const [loading, setLoading] = useState(false);

  async function handleCheckout() {
    setLoading(true);
    try {
      const loaded = await loadRazorpayScript();
      if (!loaded) {
        toast.error("Failed to load payment gateway");
        return;
      }

      // Create subscription on server
      const res = await fetch("/api/payments/razorpay/create-subscription", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ planSlug, workspaceId }),
      });

      if (!res.ok) {
        const data = await res.json();
        toast.error(data.error ?? "Failed to create subscription");
        return;
      }

      const { subscriptionId } = await res.json();

      const options = {
        key: process.env.NEXT_PUBLIC_RAZORPAY_KEY_ID,
        subscription_id: subscriptionId,
        name: "VoiceTask",
        description: `${planName} Plan — ${priceDisplay}`,
        handler: () => {
          toast.success("Payment successful! Your plan is now active.");
          onSuccess?.();
        },
        modal: {
          ondismiss: () => {
            toast.info("Payment cancelled");
          },
        },
        theme: { color: "#6366f1" },
      };

      const rzp = new window.Razorpay(options);
      rzp.open();
    } catch (err) {
      toast.error("Something went wrong. Please try again.");
      console.error("Checkout error:", err);
    } finally {
      setLoading(false);
    }
  }

  return (
    <Button
      className="w-full"
      variant={variant}
      disabled={disabled || loading}
      onClick={handleCheckout}
    >
      {loading ? "Processing..." : disabled ? "Current Plan" : "Upgrade"}
    </Button>
  );
}
```

**Step 2: Write component test**

```typescript
// __tests__/components/billing/razorpay-checkout.test.tsx
import { describe, it, expect, vi, beforeEach } from "vitest";
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { RazorpayCheckout } from "@/components/billing/razorpay-checkout";

vi.mock("sonner", () => ({
  toast: { success: vi.fn(), error: vi.fn(), info: vi.fn() },
}));

describe("RazorpayCheckout", () => {
  it("renders Upgrade button", () => {
    render(
      <RazorpayCheckout
        planSlug="solo"
        planName="Solo"
        workspaceId="ws-1"
        priceDisplay="₹499/mo"
      />
    );
    expect(screen.getByRole("button", { name: "Upgrade" })).toBeInTheDocument();
  });

  it("shows Current Plan when disabled", () => {
    render(
      <RazorpayCheckout
        planSlug="solo"
        planName="Solo"
        workspaceId="ws-1"
        priceDisplay="₹499/mo"
        disabled
      />
    );
    expect(screen.getByRole("button", { name: "Current Plan" })).toBeDisabled();
  });
});
```

**Step 3: Run test**

Run: `npx vitest run __tests__/components/billing/razorpay-checkout.test.tsx`

**Step 4: Commit**

```bash
git add components/billing/razorpay-checkout.tsx __tests__/components/billing/razorpay-checkout.test.tsx
git commit -m "feat: add RazorpayCheckout component with checkout.js integration"
```

---

### Task 8: Create components/billing/pricing-cards.tsx

**Files:**
- Create: `components/billing/pricing-cards.tsx`
- Test: `__tests__/components/billing/pricing-cards.test.tsx`

**Step 1: Implement the component**

Extract plan cards from `app/billing/page.tsx:111-164` into a reusable component that uses `RazorpayCheckout` instead of the dead `<Button>`.

```typescript
"use client";

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Check } from "lucide-react";
import { RazorpayCheckout } from "./razorpay-checkout";
import type { Plan } from "@/lib/db/schema";

type PricingCardsProps = {
  plans: Plan[];
  currentPlanName: string | null;
  currency: "INR" | "USD";
  workspaceId: string;
  onSubscriptionChange?: () => void;
};

export function PricingCards({
  plans,
  currentPlanName,
  currency,
  workspaceId,
  onSubscriptionChange,
}: PricingCardsProps) {
  return (
    <div className="grid gap-6 md:grid-cols-3">
      {plans.map((plan) => {
        const isCurrent = currentPlanName === plan.name;
        const price = currency === "INR" ? plan.price_inr : plan.price_usd;
        const symbol = currency === "INR" ? "₹" : "$";
        const features = (plan.features as string[]) ?? [];

        return (
          <Card key={plan.id} className={`relative ${isCurrent ? "border-primary ring-2 ring-primary/20" : ""}`}>
            {isCurrent && (
              <div className="absolute -top-3 left-1/2 -translate-x-1/2">
                <Badge>Current Plan</Badge>
              </div>
            )}
            <CardHeader>
              <CardTitle>{plan.name}</CardTitle>
              <CardDescription>
                <span className="text-3xl font-bold text-foreground">{symbol}{price}</span>
                <span className="text-muted-foreground">/month</span>
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2 text-sm">
                <div className="flex items-center gap-2">
                  <Check className="h-4 w-4 text-green-500" />
                  <span>{plan.max_users === -1 ? "Unlimited" : plan.max_users} user{plan.max_users !== 1 ? "s" : ""}</span>
                </div>
                <div className="flex items-center gap-2">
                  <Check className="h-4 w-4 text-green-500" />
                  <span>{plan.max_projects === -1 ? "Unlimited" : plan.max_projects} project{plan.max_projects !== 1 ? "s" : ""}</span>
                </div>
                <div className="flex items-center gap-2">
                  <Check className="h-4 w-4 text-green-500" />
                  <span>{plan.max_workspaces === -1 ? "Unlimited" : plan.max_workspaces} workspace{plan.max_workspaces !== 1 ? "s" : ""}</span>
                </div>
                {features.map((f) => (
                  <div key={f} className="flex items-center gap-2">
                    <Check className="h-4 w-4 text-green-500" />
                    <span>{f.replace(/_/g, " ")}</span>
                  </div>
                ))}
              </div>
              <RazorpayCheckout
                planSlug={plan.slug}
                planName={plan.name}
                workspaceId={workspaceId}
                priceDisplay={`${symbol}${price}/mo`}
                disabled={isCurrent}
                variant={isCurrent ? "outline" : "default"}
                onSuccess={onSubscriptionChange}
              />
            </CardContent>
          </Card>
        );
      })}
    </div>
  );
}
```

**Step 2: Write component test**

```typescript
// __tests__/components/billing/pricing-cards.test.tsx
import { describe, it, expect, vi } from "vitest";
import { render, screen } from "@testing-library/react";
import { PricingCards } from "@/components/billing/pricing-cards";
import { createSoloPlan, createTeamPlan, createMockPlan } from "../../utils/test-helpers";

vi.mock("sonner", () => ({ toast: { success: vi.fn(), error: vi.fn(), info: vi.fn() } }));

describe("PricingCards", () => {
  const plans = [createSoloPlan(), createTeamPlan(), createMockPlan()];

  it("renders all plan cards", () => {
    render(<PricingCards plans={plans} currentPlanName={null} currency="INR" workspaceId="ws-1" />);
    expect(screen.getByText("Solo")).toBeInTheDocument();
    expect(screen.getByText("Team")).toBeInTheDocument();
    expect(screen.getByText("Agency")).toBeInTheDocument();
  });

  it("shows INR prices by default", () => {
    render(<PricingCards plans={plans} currentPlanName={null} currency="INR" workspaceId="ws-1" />);
    expect(screen.getByText(/₹499/)).toBeInTheDocument();
    expect(screen.getByText(/₹999/)).toBeInTheDocument();
    expect(screen.getByText(/₹1999/)).toBeInTheDocument();
  });

  it("shows USD prices when currency is USD", () => {
    render(<PricingCards plans={plans} currentPlanName={null} currency="USD" workspaceId="ws-1" />);
    expect(screen.getByText(/\$9/)).toBeInTheDocument();
    expect(screen.getByText(/\$19/)).toBeInTheDocument();
    expect(screen.getByText(/\$35/)).toBeInTheDocument();
  });

  it("marks current plan", () => {
    render(<PricingCards plans={plans} currentPlanName="Team" currency="INR" workspaceId="ws-1" />);
    expect(screen.getByText("Current Plan")).toBeInTheDocument();
  });

  it("shows Unlimited for -1 values", () => {
    render(<PricingCards plans={plans} currentPlanName={null} currency="INR" workspaceId="ws-1" />);
    expect(screen.getAllByText(/Unlimited/).length).toBeGreaterThanOrEqual(2);
  });
});
```

**Step 3: Run test**

Run: `npx vitest run __tests__/components/billing/pricing-cards.test.tsx`

**Step 4: Commit**

```bash
git add components/billing/pricing-cards.tsx __tests__/components/billing/pricing-cards.test.tsx
git commit -m "feat: add PricingCards component with Razorpay checkout integration"
```

---

### Task 9: Wire up billing page with new components

**Files:**
- Modify: `app/billing/page.tsx`

**Step 1: Replace inline plan cards with PricingCards component**

Replace lines 111-164 (the inline plan grid) with:
```typescript
import { PricingCards } from "@/components/billing/pricing-cards";
```

And in the JSX, replace the `<div className="grid gap-6 md:grid-cols-3">` block with:
```typescript
<PricingCards
  plans={plans}
  currentPlanName={subStatus?.planName ?? null}
  currency={currency}
  workspaceId={currentWorkspace?.id ?? ""}
  onSubscriptionChange={() => window.location.reload()}
/>
```

Also add real payment history query (import `getPaymentHistory` from subscriptions and display in the Payment History card).

**Step 2: Verify build**

Run: `npm run build`
Expected: Compiles successfully

**Step 3: Commit**

```bash
git add app/billing/page.tsx
git commit -m "feat: wire billing page with PricingCards and Razorpay checkout"
```

---

### Task 10: Implement upgrade/downgrade logic

**Files:**
- Modify: `lib/payments/razorpay.ts` (updateRazorpaySubscription already exists)
- Create: `lib/api/subscription-actions.ts`

**Step 1: Create server action for plan change**

```typescript
// lib/api/subscription-actions.ts
"use server";

import { db } from "@/lib/db";
import { subscriptions, plans } from "@/lib/db/schema";
import { eq } from "drizzle-orm";
import { getSubscription } from "./subscriptions";
import { updateRazorpaySubscription } from "@/lib/payments/razorpay";

export async function changePlan(workspaceId: string, newPlanSlug: string) {
  const sub = await getSubscription(workspaceId);
  if (!sub) throw new Error("No subscription found");
  if (!sub.provider_subscription_id) throw new Error("No Razorpay subscription linked");

  const newPlan = await db.query.plans.findFirst({
    where: eq(plans.slug, newPlanSlug),
  });
  if (!newPlan || !newPlan.razorpay_plan_id) throw new Error("Plan not found or not configured");

  // Update in Razorpay (handles proration)
  await updateRazorpaySubscription(sub.provider_subscription_id, newPlan.razorpay_plan_id);

  // Update our DB
  await db.update(subscriptions)
    .set({ plan_id: newPlan.id, updated_at: new Date() })
    .where(eq(subscriptions.id, sub.id));

  return { success: true, newPlan: newPlan.name };
}
```

**Step 2: Commit**

```bash
git add lib/api/subscription-actions.ts
git commit -m "feat: add plan upgrade/downgrade via Razorpay proration"
```

---

### Task 11: Implement cancellation flow

**Files:**
- Modify: `lib/api/subscription-actions.ts`
- Modify: `app/billing/page.tsx` — add cancel button

**Step 1: Add cancel and reactivate actions**

Add to `lib/api/subscription-actions.ts`:

```typescript
export async function cancelSubscription(workspaceId: string) {
  const sub = await getSubscription(workspaceId);
  if (!sub) throw new Error("No subscription found");
  if (!sub.provider_subscription_id) throw new Error("No Razorpay subscription linked");

  await cancelRazorpaySubscription(sub.provider_subscription_id, true);

  await db.update(subscriptions)
    .set({ cancel_at_period_end: true, updated_at: new Date() })
    .where(eq(subscriptions.id, sub.id));

  return { success: true };
}
```

**Step 2: Add cancel button to billing page**

In the Current Plan card on `app/billing/page.tsx`, add a "Cancel Subscription" button (with confirmation dialog) for active paid subscriptions. Show "Cancels at end of period" text when `cancel_at_period_end` is true.

**Step 3: Commit**

```bash
git add lib/api/subscription-actions.ts app/billing/page.tsx
git commit -m "feat: add subscription cancellation with period-end grace"
```

---

### Task 12: Run full test suite + verify build

**Step 1: Run all tests**

Run: `npx vitest run`
Expected: All tests pass

**Step 2: Run coverage**

Run: `npx vitest run --coverage`
Expected: Server action and component coverage meets targets

**Step 3: Verify build**

Run: `npm run build`
Expected: Compiles with no errors

**Step 4: Commit any fixes needed**

**Step 5: Final commit for sprint**

```bash
git add -A
git commit -m "feat: Sprint 1.2 — Razorpay subscription integration"
```
