# Sprint 5.1 — Timesheet Export + File Attachments Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add CSV/PDF timesheet export and file attachments for todos with local filesystem storage.

**Architecture:** Export via API route with auth checks. File attachments stored locally in `public/uploads/` with metadata in DB. Storage limits enforced per plan.

**Tech Stack:** jsPDF + jspdf-autotable for PDF, native JS for CSV, Next.js API routes, Drizzle ORM, local filesystem via `fs/promises`

---

### Task 1: Install jsPDF dependencies

**Files:**
- Modify: `package.json`

**Step 1: Install jspdf and autotable plugin**

Run: `npm install jspdf jspdf-autotable`

**Step 2: Commit**

```bash
git add package.json package-lock.json
git commit -m "chore: add jspdf and jspdf-autotable for timesheet export"
```

---

### Task 2: Create CSV export utility

**Files:**
- Create: `lib/api/export.ts`
- Test: `__tests__/lib/api/export.test.ts`

**Step 1: Write the failing test**

Create `__tests__/lib/api/export.test.ts`:

```ts
import { describe, it, expect } from "vitest"
import { generateTimesheetCSV } from "@/lib/api/export"

const mockEntries = [
  {
    id: "1",
    user_id: "u1",
    workspace_id: "w1",
    date: "2026-02-15",
    project_name: "Acme Website",
    task_description: "Homepage redesign",
    hours: 3.5,
    notes: "Finished hero section",
    created_at: new Date("2026-02-15"),
    updated_at: new Date("2026-02-15"),
  },
  {
    id: "2",
    user_id: "u1",
    workspace_id: "w1",
    date: "2026-02-16",
    project_name: "Internal Tools",
    task_description: "Bug fixes",
    hours: 2,
    notes: null,
    created_at: new Date("2026-02-16"),
    updated_at: new Date("2026-02-16"),
  },
]

describe("generateTimesheetCSV", () => {
  it("generates valid CSV with headers", () => {
    const csv = generateTimesheetCSV(mockEntries)
    const lines = csv.split("\n")
    expect(lines[0]).toBe("Date,Project,Task,Hours,Notes")
  })

  it("includes all entries", () => {
    const csv = generateTimesheetCSV(mockEntries)
    const lines = csv.split("\n").filter((l) => l.trim())
    expect(lines.length).toBe(3) // header + 2 entries
  })

  it("handles null notes", () => {
    const csv = generateTimesheetCSV(mockEntries)
    expect(csv).toContain("Bug fixes,2,")
  })

  it("escapes commas in fields", () => {
    const entries = [
      {
        ...mockEntries[0],
        task_description: "Fix header, footer, and nav",
      },
    ]
    const csv = generateTimesheetCSV(entries)
    expect(csv).toContain('"Fix header, footer, and nav"')
  })

  it("returns empty CSV with just headers for no entries", () => {
    const csv = generateTimesheetCSV([])
    expect(csv.trim()).toBe("Date,Project,Task,Hours,Notes")
  })

  it("adds summary row with total hours", () => {
    const csv = generateTimesheetCSV(mockEntries)
    expect(csv).toContain("Total,,5.5")
  })
})
```

**Step 2: Run test to verify it fails**

Run: `npx vitest run __tests__/lib/api/export.test.ts`
Expected: FAIL — module not found

**Step 3: Write minimal implementation**

Create `lib/api/export.ts`:

```ts
import type { TimesheetEntry } from "@/lib/db/schema"

function escapeCSV(value: string): string {
  if (value.includes(",") || value.includes('"') || value.includes("\n")) {
    return `"${value.replace(/"/g, '""')}"`
  }
  return value
}

export function generateTimesheetCSV(entries: TimesheetEntry[]): string {
  const headers = "Date,Project,Task,Hours,Notes"
  const rows = entries.map((e) =>
    [
      e.date,
      escapeCSV(e.project_name),
      escapeCSV(e.task_description),
      e.hours,
      e.notes ? escapeCSV(e.notes) : "",
    ].join(",")
  )

  const totalHours = entries.reduce((sum, e) => sum + e.hours, 0)
  const totalRow = `Total,,${totalHours},,`

  return [headers, ...rows, totalRow].join("\n")
}
```

**Step 4: Run test to verify it passes**

Run: `npx vitest run __tests__/lib/api/export.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add lib/api/export.ts __tests__/lib/api/export.test.ts
git commit -m "feat: add CSV export utility for timesheets"
```

---

### Task 3: Create PDF export utility

**Files:**
- Modify: `lib/api/export.ts`
- Modify: `__tests__/lib/api/export.test.ts`

**Step 1: Write the failing test**

Add to `__tests__/lib/api/export.test.ts`:

```ts
import { generateTimesheetPDF } from "@/lib/api/export"

describe("generateTimesheetPDF", () => {
  it("returns an ArrayBuffer", () => {
    const result = generateTimesheetPDF(mockEntries, "Acme Corp", "Feb 15 - Feb 28, 2026")
    expect(result).toBeInstanceOf(ArrayBuffer)
  })

  it("returns non-empty output for entries", () => {
    const result = generateTimesheetPDF(mockEntries, "Acme Corp", "Feb 15 - Feb 28, 2026")
    expect(result.byteLength).toBeGreaterThan(0)
  })

  it("handles empty entries", () => {
    const result = generateTimesheetPDF([], "Acme Corp", "Feb 2026")
    expect(result).toBeInstanceOf(ArrayBuffer)
  })
})
```

**Step 2: Run test to verify it fails**

Run: `npx vitest run __tests__/lib/api/export.test.ts`
Expected: FAIL — function not exported

**Step 3: Add PDF generation to export.ts**

Add to `lib/api/export.ts`:

```ts
import jsPDF from "jspdf"
import autoTable from "jspdf-autotable"

export function generateTimesheetPDF(
  entries: TimesheetEntry[],
  workspaceName: string,
  dateRange: string
): ArrayBuffer {
  const doc = new jsPDF()

  // Header
  doc.setFontSize(18)
  doc.text(workspaceName, 14, 22)
  doc.setFontSize(12)
  doc.text("Timesheet Report", 14, 30)
  doc.setFontSize(10)
  doc.setTextColor(100)
  doc.text(dateRange, 14, 36)

  // Table
  const tableData = entries.map((e) => [
    e.date,
    e.project_name,
    e.task_description,
    e.hours.toString(),
    e.notes || "",
  ])

  const totalHours = entries.reduce((sum, e) => sum + e.hours, 0)
  tableData.push(["", "", "Total", totalHours.toString(), ""])

  autoTable(doc, {
    startY: 42,
    head: [["Date", "Project", "Task", "Hours", "Notes"]],
    body: tableData,
    styles: { fontSize: 9 },
    headStyles: { fillColor: [41, 128, 185] },
    footStyles: { fontStyle: "bold" },
  })

  return doc.output("arraybuffer")
}
```

**Step 4: Run test to verify it passes**

Run: `npx vitest run __tests__/lib/api/export.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add lib/api/export.ts __tests__/lib/api/export.test.ts
git commit -m "feat: add PDF export utility for timesheets"
```

---

### Task 4: Create export API route

**Files:**
- Create: `app/api/export/timesheet/route.ts`

**Step 1: Create the export API route**

```ts
import { NextRequest, NextResponse } from "next/server"
import { getServerSession } from "next-auth"
import { authOptions } from "@/lib/auth/auth-options"
import { getTimesheetEntries } from "@/lib/api/timesheet"
import { generateTimesheetCSV, generateTimesheetPDF } from "@/lib/api/export"
import { format } from "date-fns"

export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions)
  if (!session?.user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  const userId = (session.user as any).id
  const { searchParams } = new URL(request.url)
  const workspaceId = searchParams.get("workspaceId")
  const formatType = searchParams.get("format") || "csv"
  const startDate = searchParams.get("startDate") || undefined
  const endDate = searchParams.get("endDate") || undefined
  const workspaceName = searchParams.get("workspaceName") || "Workspace"

  if (!workspaceId) {
    return NextResponse.json({ error: "workspaceId is required" }, { status: 400 })
  }

  try {
    const entries = await getTimesheetEntries(workspaceId, userId, startDate, endDate)

    if (formatType === "pdf") {
      const dateRange = startDate && endDate
        ? `${format(new Date(startDate), "MMM d, yyyy")} — ${format(new Date(endDate), "MMM d, yyyy")}`
        : "All Time"
      const buffer = generateTimesheetPDF(entries, workspaceName, dateRange)
      return new NextResponse(buffer, {
        headers: {
          "Content-Type": "application/pdf",
          "Content-Disposition": `attachment; filename="timesheet-${startDate || "all"}-to-${endDate || "now"}.pdf"`,
        },
      })
    }

    // Default: CSV
    const csv = generateTimesheetCSV(entries)
    return new NextResponse(csv, {
      headers: {
        "Content-Type": "text/csv",
        "Content-Disposition": `attachment; filename="timesheet-${startDate || "all"}-to-${endDate || "now"}.csv"`,
      },
    })
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}
```

**Step 2: Commit**

```bash
git add app/api/export/timesheet/route.ts
git commit -m "feat: add timesheet export API route (CSV/PDF)"
```

---

### Task 5: Add export UI to timesheet page

**Files:**
- Modify: `components/timesheet/timesheet-list.tsx`

**Step 1: Add export dropdown to the timesheet toolbar**

Read `components/timesheet/timesheet-list.tsx` and find the toolbar area (near the date filters and "New Entry" button). Add:

1. Import `Download` and `FileText` icons from lucide-react
2. Import `DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger` from `@/components/ui/dropdown-menu`
3. Add an export dropdown button next to existing toolbar buttons:

```tsx
const handleExport = async (format: "csv" | "pdf") => {
  if (!workspaceId) return
  const params = new URLSearchParams({
    workspaceId,
    format,
    startDate: dateFrom,
    endDate: dateTo,
    workspaceName: currentWorkspace?.name || "Workspace",
  })
  const response = await fetch(`/api/export/timesheet?${params}`)
  if (!response.ok) {
    toast.error("Export failed")
    return
  }
  const blob = await response.blob()
  const url = URL.createObjectURL(blob)
  const a = document.createElement("a")
  a.href = url
  a.download = `timesheet-${dateFrom}-to-${dateTo}.${format}`
  a.click()
  URL.revokeObjectURL(url)
  toast.success(`Timesheet exported as ${format.toUpperCase()}`)
}
```

```tsx
<DropdownMenu>
  <DropdownMenuTrigger asChild>
    <Button variant="outline" size="sm">
      <Download className="mr-2 size-4" />
      Export
    </Button>
  </DropdownMenuTrigger>
  <DropdownMenuContent align="end">
    <DropdownMenuItem onClick={() => handleExport("csv")}>
      <FileText className="mr-2 size-4" />
      Export as CSV
    </DropdownMenuItem>
    <DropdownMenuItem onClick={() => handleExport("pdf")}>
      <FileText className="mr-2 size-4" />
      Export as PDF
    </DropdownMenuItem>
  </DropdownMenuContent>
</DropdownMenu>
```

Place this next to the "New Entry" button in the toolbar.

**Step 2: Commit**

```bash
git add components/timesheet/timesheet-list.tsx
git commit -m "feat: add export dropdown to timesheet page (CSV/PDF)"
```

---

### Task 6: Add attachments table to schema

**Files:**
- Modify: `lib/db/schema.ts`

**Step 1: Add attachments table after the comments table**

```ts
export const attachments = pgTable("attachments", {
  id: uuid("id").defaultRandom().primaryKey(),
  todo_id: uuid("todo_id").references(() => todos.id, { onDelete: "cascade" }).notNull(),
  user_id: uuid("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
  workspace_id: uuid("workspace_id").references(() => workspaces.id, { onDelete: "cascade" }).notNull(),
  file_name: text("file_name").notNull(),
  file_key: text("file_key").notNull(),
  file_size: integer("file_size").notNull(),
  mime_type: text("mime_type").notNull(),
  created_at: timestamp("created_at").defaultNow().notNull(),
}, (table) => ({
  todoIdx: index("attachments_todo_id_idx").on(table.todo_id),
  workspaceIdx: index("attachments_workspace_id_idx").on(table.workspace_id),
}));
```

**Step 2: Add relations**

In `todosRelations`, add: `attachments: many(attachments)`

Add new relations block:

```ts
export const attachmentsRelations = relations(attachments, ({ one }) => ({
  todo: one(todos, {
    fields: [attachments.todo_id],
    references: [todos.id],
  }),
  user: one(users, {
    fields: [attachments.user_id],
    references: [users.id],
  }),
  workspace: one(workspaces, {
    fields: [attachments.workspace_id],
    references: [workspaces.id],
  }),
}));
```

**Step 3: Add types at bottom**

```ts
export type Attachment = typeof attachments.$inferSelect;
export type NewAttachment = typeof attachments.$inferInsert;
```

**Step 4: Add max_storage_mb column to plans table**

```ts
max_storage_mb: integer("max_storage_mb").notNull().default(100),
```

**Step 5: Run migrations**

Run: `npm run db:generate && npm run db:push`

**Step 6: Commit**

```bash
git add lib/db/schema.ts drizzle/
git commit -m "feat: add attachments table and max_storage_mb to plans schema"
```

---

### Task 7: Create storage helper (local filesystem)

**Files:**
- Create: `lib/storage/index.ts`
- Test: `__tests__/lib/storage/index.test.ts`

**Step 1: Write the failing test**

Create `__tests__/lib/storage/index.test.ts`:

```ts
import { describe, it, expect, vi, beforeEach } from "vitest"
import { getFileUrl, getStorageKey, ALLOWED_MIME_TYPES, MAX_FILE_SIZE } from "@/lib/storage"

describe("getStorageKey", () => {
  it("generates correct path", () => {
    const key = getStorageKey("w1", "t1", "screenshot.png")
    expect(key).toBe("uploads/w1/t1/screenshot.png")
  })

  it("sanitizes filename", () => {
    const key = getStorageKey("w1", "t1", "my file (1).png")
    expect(key).not.toContain(" ")
    expect(key).not.toContain("(")
  })
})

describe("getFileUrl", () => {
  it("returns public URL path", () => {
    const url = getFileUrl("uploads/w1/t1/screenshot.png")
    expect(url).toBe("/uploads/w1/t1/screenshot.png")
  })
})

describe("constants", () => {
  it("has allowed MIME types", () => {
    expect(ALLOWED_MIME_TYPES).toContain("image/png")
    expect(ALLOWED_MIME_TYPES).toContain("application/pdf")
  })

  it("max file size is 10MB", () => {
    expect(MAX_FILE_SIZE).toBe(10 * 1024 * 1024)
  })
})
```

**Step 2: Run test to verify it fails**

Run: `npx vitest run __tests__/lib/storage/index.test.ts`
Expected: FAIL

**Step 3: Write implementation**

Create `lib/storage/index.ts`:

```ts
import { mkdir, writeFile, unlink } from "fs/promises"
import path from "path"

export const MAX_FILE_SIZE = 10 * 1024 * 1024 // 10MB

export const ALLOWED_MIME_TYPES = [
  "image/png",
  "image/jpeg",
  "image/gif",
  "image/webp",
  "application/pdf",
  "application/msword",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "application/vnd.ms-excel",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  "text/plain",
]

function sanitizeFilename(name: string): string {
  return name
    .replace(/[^a-zA-Z0-9._-]/g, "-")
    .replace(/-+/g, "-")
    .toLowerCase()
}

export function getStorageKey(workspaceId: string, todoId: string, fileName: string): string {
  return `uploads/${workspaceId}/${todoId}/${sanitizeFilename(fileName)}`
}

export function getFileUrl(fileKey: string): string {
  return `/${fileKey}`
}

export async function uploadFile(fileKey: string, data: Buffer): Promise<void> {
  const filePath = path.join(process.cwd(), "public", fileKey)
  const dir = path.dirname(filePath)
  await mkdir(dir, { recursive: true })
  await writeFile(filePath, data)
}

export async function deleteFile(fileKey: string): Promise<void> {
  const filePath = path.join(process.cwd(), "public", fileKey)
  try {
    await unlink(filePath)
  } catch {
    // File may already be deleted
  }
}
```

**Step 4: Run test to verify it passes**

Run: `npx vitest run __tests__/lib/storage/index.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add lib/storage/index.ts __tests__/lib/storage/index.test.ts
git commit -m "feat: add local filesystem storage helper for file attachments"
```

---

### Task 8: Create attachment server actions

**Files:**
- Create: `lib/api/attachments.ts`
- Test: `__tests__/lib/api/attachments.test.ts`

**Step 1: Write the failing test**

Create `__tests__/lib/api/attachments.test.ts`:

```ts
import { describe, it, expect, vi, beforeEach } from "vitest"

vi.mock("@/lib/db", () => ({
  db: {
    insert: vi.fn().mockReturnValue({ values: vi.fn().mockReturnValue({ returning: vi.fn().mockResolvedValue([{ id: "a1" }]) }) }),
    delete: vi.fn().mockReturnValue({ where: vi.fn().mockResolvedValue(undefined) }),
    select: vi.fn().mockReturnValue({
      from: vi.fn().mockReturnValue({
        where: vi.fn().mockResolvedValue([{ total: 5000 }]),
      }),
    }),
    query: {
      attachments: {
        findMany: vi.fn().mockResolvedValue([]),
        findFirst: vi.fn().mockResolvedValue(null),
      },
    },
  },
}))

vi.mock("@/lib/auth/permissions", () => ({
  getMemberRole: vi.fn().mockResolvedValue("member"),
}))

vi.mock("@/lib/storage", () => ({
  deleteFile: vi.fn().mockResolvedValue(undefined),
}))

import { getAttachments, canUploadFile } from "@/lib/api/attachments"

describe("getAttachments", () => {
  it("returns attachments for a todo", async () => {
    const result = await getAttachments("w1", "u1", "t1")
    expect(result).toEqual([])
  })
})

describe("canUploadFile", () => {
  it("returns allowed when under storage limit", async () => {
    const result = await canUploadFile("w1", 1000)
    expect(result.allowed).toBe(true)
  })
})
```

**Step 2: Write implementation**

Create `lib/api/attachments.ts`:

```ts
"use server"

import { db } from "@/lib/db"
import { attachments, plans, subscriptions } from "@/lib/db/schema"
import { eq, and, sql } from "drizzle-orm"
import { getMemberRole } from "@/lib/auth/permissions"
import { deleteFile } from "@/lib/storage"
import type { Attachment, NewAttachment } from "@/lib/db/schema"

export async function getAttachments(workspaceId: string, userId: string, todoId: string): Promise<Attachment[]> {
  const role = await getMemberRole(userId, workspaceId)
  if (!role) throw new Error("Not a member of this workspace")

  return db.query.attachments.findMany({
    where: and(
      eq(attachments.todo_id, todoId),
      eq(attachments.workspace_id, workspaceId)
    ),
  })
}

export async function createAttachment(
  workspaceId: string,
  userId: string,
  data: Omit<NewAttachment, "user_id" | "workspace_id">
): Promise<Attachment> {
  const role = await getMemberRole(userId, workspaceId)
  if (!role) throw new Error("Not a member of this workspace")

  const [attachment] = await db
    .insert(attachments)
    .values({ ...data, user_id: userId, workspace_id: workspaceId } as any)
    .returning()

  return attachment
}

export async function deleteAttachment(workspaceId: string, userId: string, attachmentId: string): Promise<void> {
  const role = await getMemberRole(userId, workspaceId)
  if (!role) throw new Error("Not a member of this workspace")

  const attachment = await db.query.attachments.findFirst({
    where: eq(attachments.id, attachmentId),
  })
  if (!attachment) throw new Error("Attachment not found")

  if (attachment.user_id !== userId && role === "member") {
    throw new Error("Not authorized to delete this attachment")
  }

  await deleteFile(attachment.file_key)
  await db.delete(attachments).where(eq(attachments.id, attachmentId))
}

export async function getWorkspaceStorageUsed(workspaceId: string): Promise<number> {
  const [result] = await db
    .select({ total: sql<number>`COALESCE(SUM(${attachments.file_size}), 0)` })
    .from(attachments)
    .where(eq(attachments.workspace_id, workspaceId))

  return Number(result.total)
}

export async function canUploadFile(
  workspaceId: string,
  fileSize: number
): Promise<{ allowed: boolean; reason?: string; currentUsageMB?: number; limitMB?: number }> {
  const sub = await db.query.subscriptions.findFirst({
    where: eq(subscriptions.workspace_id, workspaceId),
    with: { plan: true },
    orderBy: (s, { desc }) => [desc(s.created_at)],
  })

  if (!sub) return { allowed: false, reason: "No active subscription" }

  const limitMB = (sub.plan as any).max_storage_mb ?? 100
  const currentUsage = await getWorkspaceStorageUsed(workspaceId)
  const currentUsageMB = Math.round(currentUsage / 1024 / 1024)
  const newTotalMB = Math.round((currentUsage + fileSize) / 1024 / 1024)

  if (newTotalMB > limitMB) {
    return {
      allowed: false,
      reason: `Storage limit exceeded (${currentUsageMB}MB / ${limitMB}MB)`,
      currentUsageMB,
      limitMB,
    }
  }

  return { allowed: true, currentUsageMB, limitMB }
}
```

**Step 3: Run test**

Run: `npx vitest run __tests__/lib/api/attachments.test.ts`
Expected: PASS

**Step 4: Commit**

```bash
git add lib/api/attachments.ts __tests__/lib/api/attachments.test.ts
git commit -m "feat: add attachment server actions (CRUD, storage check)"
```

---

### Task 9: Create file upload API route

**Files:**
- Create: `app/api/upload/route.ts`

**Step 1: Create the upload route**

```ts
import { NextRequest, NextResponse } from "next/server"
import { getServerSession } from "next-auth"
import { authOptions } from "@/lib/auth/auth-options"
import { uploadFile, getStorageKey, ALLOWED_MIME_TYPES, MAX_FILE_SIZE } from "@/lib/storage"
import { createAttachment, canUploadFile } from "@/lib/api/attachments"

export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions)
  if (!session?.user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  const userId = (session.user as any).id

  try {
    const formData = await request.formData()
    const file = formData.get("file") as File | null
    const workspaceId = formData.get("workspaceId") as string
    const todoId = formData.get("todoId") as string

    if (!file || !workspaceId || !todoId) {
      return NextResponse.json({ error: "file, workspaceId, and todoId are required" }, { status: 400 })
    }

    if (!ALLOWED_MIME_TYPES.includes(file.type)) {
      return NextResponse.json({ error: "File type not allowed" }, { status: 400 })
    }

    if (file.size > MAX_FILE_SIZE) {
      return NextResponse.json({ error: "File too large (max 10MB)" }, { status: 400 })
    }

    const storageCheck = await canUploadFile(workspaceId, file.size)
    if (!storageCheck.allowed) {
      return NextResponse.json({ error: storageCheck.reason }, { status: 403 })
    }

    const fileKey = getStorageKey(workspaceId, todoId, file.name)
    const buffer = Buffer.from(await file.arrayBuffer())
    await uploadFile(fileKey, buffer)

    const attachment = await createAttachment(workspaceId, userId, {
      todo_id: todoId,
      file_name: file.name,
      file_key: fileKey,
      file_size: file.size,
      mime_type: file.type,
    })

    return NextResponse.json(attachment, { status: 201 })
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}
```

**Step 2: Commit**

```bash
git add app/api/upload/route.ts
git commit -m "feat: add file upload API route with validation and storage limits"
```

---

### Task 10: Create file attachment UI component

**Files:**
- Create: `components/todos/file-attachment.tsx`

**Step 1: Create the component**

```tsx
"use client"

import { useState, useRef } from "react"
import { Button } from "@/components/ui/button"
import { Paperclip, X, Download, FileText, ImageIcon, Loader2 } from "lucide-react"
import { toast } from "sonner"
import { deleteAttachment, getAttachments } from "@/lib/api/attachments"
import { getFileUrl } from "@/lib/storage"
import type { Attachment } from "@/lib/db/schema"

interface FileAttachmentProps {
  todoId: string
  workspaceId: string
  userId: string
  initialAttachments?: Attachment[]
}

export function FileAttachment({ todoId, workspaceId, userId, initialAttachments = [] }: FileAttachmentProps) {
  const [attachments, setAttachments] = useState<Attachment[]>(initialAttachments)
  const [isUploading, setIsUploading] = useState(false)
  const fileInputRef = useRef<HTMLInputElement>(null)

  const handleUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    setIsUploading(true)
    try {
      const formData = new FormData()
      formData.append("file", file)
      formData.append("workspaceId", workspaceId)
      formData.append("todoId", todoId)

      const response = await fetch("/api/upload", { method: "POST", body: formData })
      if (!response.ok) {
        const data = await response.json()
        throw new Error(data.error || "Upload failed")
      }

      const attachment = await response.json()
      setAttachments((prev) => [...prev, attachment])
      toast.success("File uploaded")
    } catch (error: any) {
      toast.error(error.message)
    } finally {
      setIsUploading(false)
      if (fileInputRef.current) fileInputRef.current.value = ""
    }
  }

  const handleDelete = async (attachmentId: string) => {
    try {
      await deleteAttachment(workspaceId, userId, attachmentId)
      setAttachments((prev) => prev.filter((a) => a.id !== attachmentId))
      toast.success("File deleted")
    } catch (error: any) {
      toast.error(error.message)
    }
  }

  const getIcon = (mimeType: string) => {
    if (mimeType.startsWith("image/")) return <ImageIcon className="size-4" />
    return <FileText className="size-4" />
  }

  const formatSize = (bytes: number) => {
    if (bytes < 1024) return `${bytes} B`
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`
    return `${(bytes / 1024 / 1024).toFixed(1)} MB`
  }

  return (
    <div className="space-y-3">
      <div className="flex items-center gap-2">
        <input
          ref={fileInputRef}
          type="file"
          className="hidden"
          onChange={handleUpload}
          accept="image/*,.pdf,.doc,.docx,.xls,.xlsx,.txt"
        />
        <Button
          variant="outline"
          size="sm"
          onClick={() => fileInputRef.current?.click()}
          disabled={isUploading}
        >
          {isUploading ? (
            <Loader2 className="mr-2 size-4 animate-spin" />
          ) : (
            <Paperclip className="mr-2 size-4" />
          )}
          {isUploading ? "Uploading..." : "Attach File"}
        </Button>
      </div>

      {attachments.length > 0 && (
        <ul className="space-y-2">
          {attachments.map((attachment) => (
            <li key={attachment.id} className="flex items-center gap-2 rounded-md border p-2 text-sm">
              {getIcon(attachment.mime_type)}
              <span className="flex-1 truncate">{attachment.file_name}</span>
              <span className="text-xs text-muted-foreground">{formatSize(attachment.file_size)}</span>
              <a
                href={getFileUrl(attachment.file_key)}
                download={attachment.file_name}
                className="text-primary hover:underline"
              >
                <Download className="size-4" />
              </a>
              <button onClick={() => handleDelete(attachment.id)} className="text-destructive hover:text-destructive/80">
                <X className="size-4" />
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  )
}
```

**Step 2: Commit**

```bash
git add components/todos/file-attachment.tsx
git commit -m "feat: add file attachment UI component for todos"
```

---

### Task 11: Wire attachments into todo detail

**Files:**
- Modify: `components/todos/todo-list.tsx` (or wherever todo detail/edit dialog lives)
- Modify: `lib/api/loaders.ts` (add attachments to todo page data)

**Step 1: Read `components/todos/todo-list.tsx` to find the todo detail/edit area**

Look for where individual todo items are rendered or where there's an edit dialog. Add the `<FileAttachment>` component below the todo description/comments area.

**Step 2: Update the todo loader to include attachments**

In `lib/api/loaders.ts`, update `loadTodoPageData` to also fetch attachments for the workspace (or load them lazily per todo).

**Step 3: Add `FileAttachment` to the todo edit dialog or inline todo view**

```tsx
import { FileAttachment } from "@/components/todos/file-attachment"

// Inside the todo detail/edit area:
<FileAttachment
  todoId={todo.id}
  workspaceId={workspaceId}
  userId={userId}
  initialAttachments={todo.attachments || []}
/>
```

**Step 4: Commit**

```bash
git add components/todos/todo-list.tsx lib/api/loaders.ts
git commit -m "feat: wire file attachments into todo detail view"
```

---

### Task 12: Add storage limit enforcement to plan enforcement

**Files:**
- Modify: `lib/api/plan-enforcement.ts`
- Modify: `lib/api/subscriptions.ts` (add maxStorageMB to PlanLimits type)

**Step 1: Update PlanLimits type in subscriptions.ts**

```ts
export type PlanLimits = {
  maxUsers: number;
  maxProjects: number;
  maxWorkspaces: number;
  maxStorageMB: number;
  features: string[];
};
```

Update `getPlanLimits` to include `maxStorageMB: plan.max_storage_mb`.

**Step 2: Update plan-enforcement.ts**

Add `canUploadFile` function to `plan-enforcement.ts` or keep it in `attachments.ts` (already done in Task 8). Just ensure `UsageInfo` type in subscriptions includes storage.

**Step 3: Update seed script to set storage limits**

Update `lib/db/seed-plans.ts` to include `max_storage_mb`:
- Solo: 100
- Team: 1024 (1GB)
- Agency: 10240 (10GB)

**Step 4: Commit**

```bash
git add lib/api/subscriptions.ts lib/api/plan-enforcement.ts lib/db/seed-plans.ts
git commit -m "feat: add storage limit enforcement to plan system"
```

---

### Task 13: Write tests for export and attachment features

**Files:**
- Modify: `__tests__/lib/api/export.test.ts` (already done in Tasks 2-3)
- Modify: `__tests__/lib/api/attachments.test.ts` (already done in Task 8)
- Create: `__tests__/components/todos/file-attachment.test.tsx`

**Step 1: Write component tests for FileAttachment**

```tsx
import { describe, it, expect, vi } from "vitest"
import { render, screen } from "@testing-library/react"
import { FileAttachment } from "@/components/todos/file-attachment"

vi.mock("@/lib/api/attachments", () => ({
  deleteAttachment: vi.fn(),
  getAttachments: vi.fn().mockResolvedValue([]),
}))

vi.mock("@/lib/storage", () => ({
  getFileUrl: vi.fn((key: string) => `/${key}`),
}))

const mockAttachments = [
  {
    id: "a1",
    todo_id: "t1",
    user_id: "u1",
    workspace_id: "w1",
    file_name: "screenshot.png",
    file_key: "uploads/w1/t1/screenshot.png",
    file_size: 1024,
    mime_type: "image/png",
    created_at: new Date(),
  },
]

describe("FileAttachment", () => {
  it("renders attach button", () => {
    render(<FileAttachment todoId="t1" workspaceId="w1" userId="u1" />)
    expect(screen.getByText("Attach File")).toBeInTheDocument()
  })

  it("renders existing attachments", () => {
    render(
      <FileAttachment todoId="t1" workspaceId="w1" userId="u1" initialAttachments={mockAttachments} />
    )
    expect(screen.getByText("screenshot.png")).toBeInTheDocument()
    expect(screen.getByText("1.0 KB")).toBeInTheDocument()
  })

  it("renders no attachments when empty", () => {
    render(<FileAttachment todoId="t1" workspaceId="w1" userId="u1" initialAttachments={[]} />)
    expect(screen.queryByRole("list")).not.toBeInTheDocument()
  })
})
```

**Step 2: Run tests**

Run: `npx vitest run __tests__/components/todos/file-attachment.test.tsx`
Expected: PASS

**Step 3: Commit**

```bash
git add __tests__/components/todos/file-attachment.test.tsx
git commit -m "test: add component tests for file attachment UI"
```

---

### Task 14: Run full test suite + build verification

**Step 1: Run full test suite**

Run: `npm run test`
Expected: All tests pass

**Step 2: Run build**

Run: `npm run build`
Expected: Build succeeds

**Step 3: Update CLAUDE.md**

Mark all Sprint 5.1 tasks as `[x]` and update progress table.

**Step 4: Commit**

```bash
git add CLAUDE.md
git commit -m "docs: mark Sprint 5.1 complete in CLAUDE.md (14/14 tasks)"
```
