# Sprint 1.3 — Stripe Integration + Email Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add Stripe payment gateway for international (USD) users and build an email system for invitations, trial expiry warnings, and payment receipts.

**Architecture:** Stripe Checkout (redirect-based) for USD payments alongside existing Razorpay (INR). Nodemailer + Gmail SMTP for transactional emails with graceful no-op when env vars are missing. Daily cron endpoint for trial expiry warnings.

**Tech Stack:** stripe, @stripe/stripe-js, nodemailer, @types/nodemailer, Next.js API routes, Drizzle ORM

---

## Task 1: Install dependencies + add env vars

**Files:**
- Modify: `package.json`

**Step 1: Install npm packages**

Run:
```bash
npm install stripe @stripe/stripe-js nodemailer && npm install -D @types/nodemailer
```

Expected: 4 packages added to package.json

**Step 2: Commit**

```bash
git add package.json package-lock.json
git commit -m "chore: install stripe, nodemailer dependencies for Sprint 1.3"
```

---

## Task 2: Schema changes — add stripe_price_id + stripe_customer_id

**Files:**
- Modify: `lib/db/schema.ts:128-142` (plans table — add `stripe_price_id`)
- Modify: `lib/db/schema.ts:57-64` (workspaces table — add `stripe_customer_id`)

**Step 1: Add `stripe_price_id` to plans table**

In `lib/db/schema.ts`, in the `plans` table definition (line 139, after `razorpay_plan_id`), add:

```typescript
stripe_price_id: text("stripe_price_id"),
```

**Step 2: Add `stripe_customer_id` to workspaces table**

In `lib/db/schema.ts`, in the `workspaces` table definition (line 63, after `updated_at`), add:

```typescript
stripe_customer_id: text("stripe_customer_id"),
```

**Step 3: Update the Plan type export**

The `Plan` type at line 364 is auto-inferred from schema, so it auto-includes new columns. No change needed.

**Step 4: Update test-helpers — add new fields to mock factories**

In `__tests__/utils/test-helpers.ts`, update `createMockPlan` to include:
```typescript
stripe_price_id: null,
```

Add `razorpay_plan_id: null` too if it's missing (check first).

**Step 5: Generate and push migration**

Run:
```bash
npm run db:generate
npm run db:push
```

Expected: New migration file created in `drizzle/`, schema pushed to local PostgreSQL.

**Step 6: Verify build**

Run: `npm run build`
Expected: Build succeeds with no type errors.

**Step 7: Commit**

```bash
git add lib/db/schema.ts drizzle/ __tests__/utils/test-helpers.ts
git commit -m "feat: add stripe_price_id and stripe_customer_id columns"
```

---

## Task 3: Create Stripe client library

**Files:**
- Create: `lib/payments/stripe.ts`
- Create: `__tests__/lib/payments/stripe.test.ts`

**Step 1: Write failing tests for Stripe helpers**

Create `__tests__/lib/payments/stripe.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";

// Mock stripe module
const mockCheckoutSessionsCreate = vi.fn();
const mockSubscriptionsCancel = vi.fn();
const mockSubscriptionsRetrieve = vi.fn();
const mockCustomersCreate = vi.fn();
const mockWebhooksConstructEvent = vi.fn();

vi.mock("stripe", () => {
  const MockStripe = function () {
    return {
      checkout: { sessions: { create: mockCheckoutSessionsCreate } },
      subscriptions: {
        cancel: mockSubscriptionsCancel,
        retrieve: mockSubscriptionsRetrieve,
      },
      customers: { create: mockCustomersCreate },
      webhooks: { constructEvent: mockWebhooksConstructEvent },
    };
  };
  MockStripe.default = MockStripe;
  return { default: MockStripe };
});

import {
  getStripe,
  createCheckoutSession,
  cancelStripeSubscription,
  verifyStripeWebhook,
} from "@/lib/payments/stripe";

describe("getStripe", () => {
  beforeEach(() => {
    process.env.STRIPE_SECRET_KEY = "sk_test_123";
  });

  it("returns a Stripe instance when env var is set", () => {
    const instance = getStripe();
    expect(instance).toBeDefined();
    expect(instance.checkout).toBeDefined();
  });

  it("returns the same singleton on subsequent calls", () => {
    const a = getStripe();
    const b = getStripe();
    expect(a).toBe(b);
  });
});

describe("createCheckoutSession", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    process.env.STRIPE_SECRET_KEY = "sk_test_123";
  });

  it("creates a checkout session and returns the URL", async () => {
    mockCheckoutSessionsCreate.mockResolvedValue({
      id: "cs_test_123",
      url: "https://checkout.stripe.com/pay/cs_test_123",
    });

    const result = await createCheckoutSession({
      priceId: "price_abc",
      customerId: "cus_123",
      workspaceId: "ws_1",
      successUrl: "http://localhost:3000/billing/success",
      cancelUrl: "http://localhost:3000/billing/cancel",
    });

    expect(result.url).toBe("https://checkout.stripe.com/pay/cs_test_123");
    expect(result.sessionId).toBe("cs_test_123");
    expect(mockCheckoutSessionsCreate).toHaveBeenCalledWith({
      customer: "cus_123",
      mode: "subscription",
      line_items: [{ price: "price_abc", quantity: 1 }],
      success_url: "http://localhost:3000/billing/success?session_id={CHECKOUT_SESSION_ID}",
      cancel_url: "http://localhost:3000/billing/cancel",
      metadata: { workspace_id: "ws_1" },
    });
  });
});

describe("cancelStripeSubscription", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("cancels at period end by default", async () => {
    mockSubscriptionsCancel.mockResolvedValue({});

    await cancelStripeSubscription("sub_123");

    expect(mockSubscriptionsCancel).toHaveBeenCalledWith("sub_123", {
      cancel_at_period_end: true,
    });
  });

  it("cancels immediately when cancelAtPeriodEnd is false", async () => {
    mockSubscriptionsCancel.mockResolvedValue({});

    await cancelStripeSubscription("sub_123", false);

    expect(mockSubscriptionsCancel).toHaveBeenCalledWith("sub_123", {
      cancel_at_period_end: false,
    });
  });
});

describe("verifyStripeWebhook", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("returns the event when signature is valid", () => {
    const mockEvent = { type: "checkout.session.completed", data: {} };
    mockWebhooksConstructEvent.mockReturnValue(mockEvent);

    const result = verifyStripeWebhook("body", "sig_123", "whsec_123");
    expect(result).toEqual(mockEvent);
  });

  it("throws when signature is invalid", () => {
    mockWebhooksConstructEvent.mockImplementation(() => {
      throw new Error("Invalid signature");
    });

    expect(() => verifyStripeWebhook("body", "bad_sig", "whsec_123")).toThrow(
      "Invalid signature"
    );
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npm run test -- __tests__/lib/payments/stripe.test.ts`
Expected: FAIL — module `@/lib/payments/stripe` not found.

**Step 3: Create `lib/payments/stripe.ts`**

```typescript
import Stripe from "stripe";

// ---------------------------------------------------------------------------
// Lazy singleton Stripe client
// ---------------------------------------------------------------------------

let stripeInstance: Stripe | null = null;

export function getStripe(): Stripe {
  if (!stripeInstance) {
    const secretKey = process.env.STRIPE_SECRET_KEY;
    if (!secretKey) {
      throw new Error(
        "Missing Stripe credentials. Set STRIPE_SECRET_KEY environment variable."
      );
    }
    stripeInstance = new Stripe(secretKey);
  }
  return stripeInstance;
}

// ---------------------------------------------------------------------------
// Checkout Session
// ---------------------------------------------------------------------------

interface CreateCheckoutOptions {
  priceId: string;
  customerId: string;
  workspaceId: string;
  successUrl: string;
  cancelUrl: string;
}

interface CheckoutResult {
  sessionId: string;
  url: string;
}

export async function createCheckoutSession(
  opts: CreateCheckoutOptions
): Promise<CheckoutResult> {
  const stripe = getStripe();

  const session = await stripe.checkout.sessions.create({
    customer: opts.customerId,
    mode: "subscription",
    line_items: [{ price: opts.priceId, quantity: 1 }],
    success_url: `${opts.successUrl}?session_id={CHECKOUT_SESSION_ID}`,
    cancel_url: opts.cancelUrl,
    metadata: { workspace_id: opts.workspaceId },
  });

  return {
    sessionId: session.id,
    url: session.url!,
  };
}

// ---------------------------------------------------------------------------
// Subscription management
// ---------------------------------------------------------------------------

export async function cancelStripeSubscription(
  subscriptionId: string,
  cancelAtPeriodEnd: boolean = true
): Promise<void> {
  const stripe = getStripe();
  await stripe.subscriptions.cancel(subscriptionId, {
    cancel_at_period_end: cancelAtPeriodEnd,
  });
}

export async function getStripeSubscription(subscriptionId: string) {
  const stripe = getStripe();
  return stripe.subscriptions.retrieve(subscriptionId);
}

// ---------------------------------------------------------------------------
// Customer management
// ---------------------------------------------------------------------------

export async function createStripeCustomer(
  email: string,
  name?: string
): Promise<string> {
  const stripe = getStripe();
  const customer = await stripe.customers.create({
    email,
    name: name ?? undefined,
  });
  return customer.id;
}

// ---------------------------------------------------------------------------
// Webhook verification
// ---------------------------------------------------------------------------

export function verifyStripeWebhook(
  body: string,
  signature: string,
  secret: string
): Stripe.Event {
  const stripe = getStripe();
  return stripe.webhooks.constructEvent(body, signature, secret);
}
```

**Step 4: Run tests to verify they pass**

Run: `npm run test -- __tests__/lib/payments/stripe.test.ts`
Expected: All tests PASS.

**Step 5: Commit**

```bash
git add lib/payments/stripe.ts __tests__/lib/payments/stripe.test.ts
git commit -m "feat: add Stripe client library with checkout, cancel, webhook helpers"
```

---

## Task 4: Create Stripe create-checkout API route

**Files:**
- Create: `app/api/payments/stripe/create-checkout/route.ts`
- Create: `__tests__/app/api/payments/stripe/create-checkout.test.ts`

**Step 1: Write failing tests**

Create `__tests__/app/api/payments/stripe/create-checkout.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";

// Mock dependencies
vi.mock("next-auth", () => ({
  getServerSession: vi.fn(),
}));

vi.mock("@/lib/auth/auth-options", () => ({
  authOptions: {},
}));

vi.mock("@/lib/db", () => ({
  db: {
    query: {
      plans: { findFirst: vi.fn() },
      workspaces: { findFirst: vi.fn() },
    },
    update: vi.fn().mockReturnThis(),
    set: vi.fn().mockReturnThis(),
    where: vi.fn().mockReturnThis(),
  },
}));

vi.mock("@/lib/payments/stripe", () => ({
  createCheckoutSession: vi.fn(),
  createStripeCustomer: vi.fn(),
}));

vi.mock("@/lib/api/subscriptions", () => ({
  getSubscription: vi.fn(),
}));

import { getServerSession } from "next-auth";
import { db } from "@/lib/db";
import { createCheckoutSession, createStripeCustomer } from "@/lib/payments/stripe";
import { POST } from "@/app/api/payments/stripe/create-checkout/route";

describe("POST /api/payments/stripe/create-checkout", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("returns 401 when not authenticated", async () => {
    vi.mocked(getServerSession).mockResolvedValue(null);

    const req = new Request("http://localhost/api/payments/stripe/create-checkout", {
      method: "POST",
      body: JSON.stringify({ planSlug: "solo", workspaceId: "ws_1" }),
    });

    const res = await POST(req as any);
    expect(res.status).toBe(401);
  });

  it("returns 400 when planSlug or workspaceId missing", async () => {
    vi.mocked(getServerSession).mockResolvedValue({
      user: { id: "user_1", email: "test@test.com" },
    } as any);

    const req = new Request("http://localhost/api/payments/stripe/create-checkout", {
      method: "POST",
      body: JSON.stringify({}),
    });

    const res = await POST(req as any);
    expect(res.status).toBe(400);
  });

  it("returns 400 when plan not found or stripe_price_id missing", async () => {
    vi.mocked(getServerSession).mockResolvedValue({
      user: { id: "user_1", email: "test@test.com" },
    } as any);
    vi.mocked(db.query.plans.findFirst).mockResolvedValue(null);

    const req = new Request("http://localhost/api/payments/stripe/create-checkout", {
      method: "POST",
      body: JSON.stringify({ planSlug: "solo", workspaceId: "ws_1" }),
    });

    const res = await POST(req as any);
    expect(res.status).toBe(400);
  });

  it("creates checkout session and returns URL on success", async () => {
    vi.mocked(getServerSession).mockResolvedValue({
      user: { id: "user_1", email: "test@test.com" },
    } as any);
    vi.mocked(db.query.plans.findFirst).mockResolvedValue({
      id: "plan_1",
      slug: "solo",
      stripe_price_id: "price_abc",
    } as any);
    vi.mocked(db.query.workspaces.findFirst).mockResolvedValue({
      id: "ws_1",
      stripe_customer_id: "cus_123",
    } as any);
    vi.mocked(createCheckoutSession).mockResolvedValue({
      sessionId: "cs_test_123",
      url: "https://checkout.stripe.com/pay/cs_test_123",
    });

    const req = new Request("http://localhost/api/payments/stripe/create-checkout", {
      method: "POST",
      body: JSON.stringify({ planSlug: "solo", workspaceId: "ws_1" }),
    });

    const res = await POST(req as any);
    const data = await res.json();
    expect(res.status).toBe(200);
    expect(data.url).toBe("https://checkout.stripe.com/pay/cs_test_123");
  });

  it("creates a Stripe customer if workspace doesn't have one", async () => {
    vi.mocked(getServerSession).mockResolvedValue({
      user: { id: "user_1", email: "test@test.com", name: "Test" },
    } as any);
    vi.mocked(db.query.plans.findFirst).mockResolvedValue({
      id: "plan_1",
      slug: "solo",
      stripe_price_id: "price_abc",
    } as any);
    vi.mocked(db.query.workspaces.findFirst).mockResolvedValue({
      id: "ws_1",
      stripe_customer_id: null,
    } as any);
    vi.mocked(createStripeCustomer).mockResolvedValue("cus_new_456");
    // Mock the chained db.update().set().where()
    const mockWhere = vi.fn().mockResolvedValue(undefined);
    const mockSet = vi.fn().mockReturnValue({ where: mockWhere });
    vi.mocked(db.update).mockReturnValue({ set: mockSet } as any);
    vi.mocked(createCheckoutSession).mockResolvedValue({
      sessionId: "cs_test_456",
      url: "https://checkout.stripe.com/pay/cs_test_456",
    });

    const req = new Request("http://localhost/api/payments/stripe/create-checkout", {
      method: "POST",
      body: JSON.stringify({ planSlug: "solo", workspaceId: "ws_1" }),
    });

    const res = await POST(req as any);
    expect(res.status).toBe(200);
    expect(createStripeCustomer).toHaveBeenCalledWith("test@test.com", "Test");
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npm run test -- __tests__/app/api/payments/stripe/create-checkout.test.ts`
Expected: FAIL — module not found.

**Step 3: Create `app/api/payments/stripe/create-checkout/route.ts`**

```typescript
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth/auth-options";
import { db } from "@/lib/db";
import { plans, workspaces } from "@/lib/db/schema";
import { eq } from "drizzle-orm";
import { createCheckoutSession, createStripeCustomer } from "@/lib/payments/stripe";

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const user = session.user as any;
    const body = await req.json();
    const { planSlug, workspaceId } = body;

    if (!planSlug || !workspaceId) {
      return NextResponse.json(
        { error: "Missing required fields: planSlug and workspaceId" },
        { status: 400 }
      );
    }

    // Look up plan
    const plan = await db.query.plans.findFirst({
      where: eq(plans.slug, planSlug),
    });

    if (!plan || !plan.stripe_price_id) {
      return NextResponse.json(
        { error: "Plan not found or Stripe price not configured" },
        { status: 400 }
      );
    }

    // Get or create Stripe customer
    const workspace = await db.query.workspaces.findFirst({
      where: eq(workspaces.id, workspaceId),
    });

    let customerId = workspace?.stripe_customer_id;

    if (!customerId) {
      customerId = await createStripeCustomer(user.email, user.name);
      await db
        .update(workspaces)
        .set({ stripe_customer_id: customerId })
        .where(eq(workspaces.id, workspaceId));
    }

    // Create checkout session
    const baseUrl = process.env.NEXTAUTH_URL ?? "http://localhost:3000";
    const result = await createCheckoutSession({
      priceId: plan.stripe_price_id,
      customerId,
      workspaceId,
      successUrl: `${baseUrl}/billing/success`,
      cancelUrl: `${baseUrl}/billing/cancel`,
    });

    return NextResponse.json({
      sessionId: result.sessionId,
      url: result.url,
    });
  } catch (error) {
    console.error("Error creating Stripe checkout:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
```

**Step 4: Run tests**

Run: `npm run test -- __tests__/app/api/payments/stripe/create-checkout.test.ts`
Expected: All tests PASS.

**Step 5: Commit**

```bash
git add app/api/payments/stripe/create-checkout/route.ts __tests__/app/api/payments/stripe/create-checkout.test.ts
git commit -m "feat: add Stripe create-checkout API route"
```

---

## Task 5: Create Stripe webhook API route

**Files:**
- Create: `app/api/payments/stripe/webhook/route.ts`
- Create: `__tests__/app/api/payments/stripe/webhook.test.ts`

**Step 1: Write failing tests**

Create `__tests__/app/api/payments/stripe/webhook.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";

vi.mock("@/lib/payments/stripe", () => ({
  verifyStripeWebhook: vi.fn(),
}));

vi.mock("@/lib/db", () => {
  const mockWhere = vi.fn().mockResolvedValue(undefined);
  const mockSet = vi.fn().mockReturnValue({ where: mockWhere });
  const mockValues = vi.fn().mockResolvedValue(undefined);
  return {
    db: {
      update: vi.fn().mockReturnValue({ set: mockSet }),
      insert: vi.fn().mockReturnValue({ values: mockValues }),
      query: {
        subscriptions: { findFirst: vi.fn() },
      },
    },
  };
});

vi.mock("@/lib/db/schema", () => ({
  subscriptions: { provider_subscription_id: "provider_subscription_id", workspace_id: "workspace_id" },
  paymentHistory: {},
}));

import { verifyStripeWebhook } from "@/lib/payments/stripe";
import { POST } from "@/app/api/payments/stripe/webhook/route";

describe("POST /api/payments/stripe/webhook", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    process.env.STRIPE_WEBHOOK_SECRET = "whsec_test_123";
  });

  it("returns 400 when stripe-signature header is missing", async () => {
    const req = new Request("http://localhost/api/payments/stripe/webhook", {
      method: "POST",
      body: "{}",
    });

    const res = await POST(req as any);
    expect(res.status).toBe(400);
  });

  it("returns 400 when signature verification fails", async () => {
    vi.mocked(verifyStripeWebhook).mockImplementation(() => {
      throw new Error("Invalid signature");
    });

    const req = new Request("http://localhost/api/payments/stripe/webhook", {
      method: "POST",
      body: "{}",
      headers: { "stripe-signature": "bad_sig" },
    });

    const res = await POST(req as any);
    expect(res.status).toBe(400);
  });

  it("handles checkout.session.completed event", async () => {
    vi.mocked(verifyStripeWebhook).mockReturnValue({
      type: "checkout.session.completed",
      data: {
        object: {
          subscription: "sub_stripe_123",
          metadata: { workspace_id: "ws_1" },
          customer: "cus_123",
        },
      },
    } as any);

    const req = new Request("http://localhost/api/payments/stripe/webhook", {
      method: "POST",
      body: "{}",
      headers: { "stripe-signature": "valid_sig" },
    });

    const res = await POST(req as any);
    expect(res.status).toBe(200);
  });

  it("returns 200 for unknown event types", async () => {
    vi.mocked(verifyStripeWebhook).mockReturnValue({
      type: "some.unknown.event",
      data: { object: {} },
    } as any);

    const req = new Request("http://localhost/api/payments/stripe/webhook", {
      method: "POST",
      body: "{}",
      headers: { "stripe-signature": "valid_sig" },
    });

    const res = await POST(req as any);
    expect(res.status).toBe(200);
  });
});
```

**Step 2: Run tests — expect fail**

Run: `npm run test -- __tests__/app/api/payments/stripe/webhook.test.ts`

**Step 3: Create `app/api/payments/stripe/webhook/route.ts`**

```typescript
import { NextRequest, NextResponse } from "next/server";
import { verifyStripeWebhook } from "@/lib/payments/stripe";
import { db } from "@/lib/db";
import { subscriptions, paymentHistory, plans } from "@/lib/db/schema";
import { eq, and } from "drizzle-orm";

export async function POST(req: NextRequest) {
  try {
    const body = await req.text();
    const signature = req.headers.get("stripe-signature");

    if (!signature) {
      return NextResponse.json({ error: "Missing signature header" }, { status: 400 });
    }

    const secret = process.env.STRIPE_WEBHOOK_SECRET;
    if (!secret) {
      console.error("STRIPE_WEBHOOK_SECRET is not set");
      return NextResponse.json({ error: "Webhook secret not configured" }, { status: 500 });
    }

    let event;
    try {
      event = verifyStripeWebhook(body, signature, secret);
    } catch {
      return NextResponse.json({ error: "Invalid signature" }, { status: 400 });
    }

    switch (event.type) {
      case "checkout.session.completed": {
        const session = event.data.object as any;
        const workspaceId = session.metadata?.workspace_id;
        const stripeSubscriptionId = session.subscription as string;

        if (workspaceId && stripeSubscriptionId) {
          // Find the plan from the subscription's price
          const sub = await db.query.subscriptions.findFirst({
            where: eq(subscriptions.workspace_id, workspaceId),
          });

          if (sub) {
            await db
              .update(subscriptions)
              .set({
                status: "active",
                payment_provider: "stripe",
                provider_subscription_id: stripeSubscriptionId,
                current_period_start: new Date(),
                current_period_end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
                updated_at: new Date(),
              })
              .where(eq(subscriptions.id, sub.id));
          }
        }
        break;
      }

      case "invoice.paid": {
        const invoice = event.data.object as any;
        const subscriptionId = invoice.subscription as string;

        const sub = await db.query.subscriptions.findFirst({
          where: eq(subscriptions.provider_subscription_id, subscriptionId),
        });

        if (sub) {
          // Update period
          await db
            .update(subscriptions)
            .set({
              current_period_start: new Date(invoice.period_start * 1000),
              current_period_end: new Date(invoice.period_end * 1000),
              updated_at: new Date(),
            })
            .where(eq(subscriptions.id, sub.id));

          // Record payment
          await db.insert(paymentHistory).values({
            workspace_id: sub.workspace_id,
            subscription_id: sub.id,
            amount: invoice.amount_paid,
            currency: (invoice.currency ?? "usd").toUpperCase(),
            provider: "stripe",
            provider_payment_id: invoice.payment_intent as string,
            status: "captured",
            description: "Subscription payment",
          });
        }
        break;
      }

      case "customer.subscription.deleted": {
        const subscription = event.data.object as any;

        await db
          .update(subscriptions)
          .set({
            status: "cancelled",
            cancel_at_period_end: false,
            updated_at: new Date(),
          })
          .where(eq(subscriptions.provider_subscription_id, subscription.id));
        break;
      }

      default:
        break;
    }

    return NextResponse.json({ status: "ok" }, { status: 200 });
  } catch (error) {
    console.error("Stripe webhook error:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
```

**Step 4: Run tests**

Run: `npm run test -- __tests__/app/api/payments/stripe/webhook.test.ts`
Expected: All PASS.

**Step 5: Commit**

```bash
git add app/api/payments/stripe/webhook/route.ts __tests__/app/api/payments/stripe/webhook.test.ts
git commit -m "feat: add Stripe webhook handler for checkout, invoice, cancellation events"
```

---

## Task 6: Create billing success/cancel pages

**Files:**
- Create: `app/billing/success/page.tsx`
- Create: `app/billing/cancel/page.tsx`

**Step 1: Create success page**

```typescript
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { AppShell } from "@/components/layout/app-shell";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { CheckCircle } from "lucide-react";

export default function BillingSuccessPage() {
  const router = useRouter();

  useEffect(() => {
    const timeout = setTimeout(() => router.push("/billing"), 5000);
    return () => clearTimeout(timeout);
  }, [router]);

  return (
    <AppShell>
      <div className="flex items-center justify-center min-h-[60vh]">
        <Card className="max-w-md text-center">
          <CardHeader>
            <div className="flex justify-center mb-4">
              <CheckCircle className="h-16 w-16 text-green-500" />
            </div>
            <CardTitle className="text-2xl">Payment Successful!</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <p className="text-muted-foreground">
              Your subscription is now active. You'll be redirected to the billing page shortly.
            </p>
            <Button onClick={() => router.push("/billing")}>
              Go to Billing
            </Button>
          </CardContent>
        </Card>
      </div>
    </AppShell>
  );
}
```

**Step 2: Create cancel page**

```typescript
"use client";

import { useRouter } from "next/navigation";
import { AppShell } from "@/components/layout/app-shell";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { XCircle } from "lucide-react";

export default function BillingCancelPage() {
  const router = useRouter();

  return (
    <AppShell>
      <div className="flex items-center justify-center min-h-[60vh]">
        <Card className="max-w-md text-center">
          <CardHeader>
            <div className="flex justify-center mb-4">
              <XCircle className="h-16 w-16 text-muted-foreground" />
            </div>
            <CardTitle className="text-2xl">Payment Cancelled</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <p className="text-muted-foreground">
              No worries — you can subscribe anytime from the billing page.
            </p>
            <Button onClick={() => router.push("/billing")}>
              Back to Billing
            </Button>
          </CardContent>
        </Card>
      </div>
    </AppShell>
  );
}
```

**Step 3: Commit**

```bash
git add app/billing/success/page.tsx app/billing/cancel/page.tsx
git commit -m "feat: add billing success and cancel redirect pages"
```

---

## Task 7: Create StripeCheckout component + update PricingCards

**Files:**
- Create: `components/billing/stripe-checkout.tsx`
- Modify: `components/billing/pricing-cards.tsx`
- Create: `__tests__/components/billing/stripe-checkout.test.tsx`

**Step 1: Write failing component test**

Create `__tests__/components/billing/stripe-checkout.test.tsx`:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import { StripeCheckout } from "@/components/billing/stripe-checkout";

// Mock fetch
global.fetch = vi.fn();

describe("StripeCheckout", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("renders the upgrade button", () => {
    render(
      <StripeCheckout
        planSlug="solo"
        planName="Solo"
        workspaceId="ws_1"
        priceDisplay="$9/mo"
      />
    );
    expect(screen.getByRole("button", { name: "Upgrade" })).toBeInTheDocument();
  });

  it("shows 'Current Plan' when disabled", () => {
    render(
      <StripeCheckout
        planSlug="solo"
        planName="Solo"
        workspaceId="ws_1"
        priceDisplay="$9/mo"
        disabled
      />
    );
    expect(screen.getByRole("button", { name: "Current Plan" })).toBeDisabled();
  });

  it("redirects to Stripe checkout URL on click", async () => {
    const mockUrl = "https://checkout.stripe.com/pay/cs_test_123";
    vi.mocked(global.fetch).mockResolvedValue({
      ok: true,
      json: () => Promise.resolve({ url: mockUrl }),
    } as any);

    // Mock window.location.href
    const originalLocation = window.location;
    Object.defineProperty(window, "location", {
      writable: true,
      value: { ...originalLocation, href: "" },
    });

    render(
      <StripeCheckout
        planSlug="solo"
        planName="Solo"
        workspaceId="ws_1"
        priceDisplay="$9/mo"
      />
    );

    fireEvent.click(screen.getByRole("button", { name: "Upgrade" }));

    await waitFor(() => {
      expect(window.location.href).toBe(mockUrl);
    });

    Object.defineProperty(window, "location", {
      writable: true,
      value: originalLocation,
    });
  });
});
```

**Step 2: Run tests — expect fail**

Run: `npm run test -- __tests__/components/billing/stripe-checkout.test.ts`

**Step 3: Create `components/billing/stripe-checkout.tsx`**

```typescript
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { toast } from "sonner";

type StripeCheckoutProps = {
  planSlug: string;
  planName: string;
  workspaceId: string;
  priceDisplay: string;
  disabled?: boolean;
  variant?: "default" | "outline";
  onSuccess?: () => void;
};

export function StripeCheckout({
  planSlug,
  planName,
  workspaceId,
  priceDisplay,
  disabled = false,
  variant = "default",
  onSuccess,
}: StripeCheckoutProps) {
  const [loading, setLoading] = useState(false);

  async function handleCheckout() {
    setLoading(true);
    try {
      const res = await fetch("/api/payments/stripe/create-checkout", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ planSlug, workspaceId }),
      });

      if (!res.ok) {
        const data = await res.json();
        toast.error(data.error ?? "Failed to create checkout session");
        return;
      }

      const { url } = await res.json();
      window.location.href = url;
    } catch (err) {
      toast.error("Something went wrong. Please try again.");
      console.error("Stripe checkout error:", err);
    } finally {
      setLoading(false);
    }
  }

  return (
    <Button
      className="w-full"
      variant={variant}
      disabled={disabled || loading}
      onClick={handleCheckout}
    >
      {loading ? "Processing..." : disabled ? "Current Plan" : "Upgrade"}
    </Button>
  );
}
```

**Step 4: Update `components/billing/pricing-cards.tsx`**

Replace the `RazorpayCheckout` import and usage. The card should show `RazorpayCheckout` when `currency === "INR"` and `StripeCheckout` when `currency === "USD"`.

Changes to `pricing-cards.tsx`:
- Add import for `StripeCheckout`
- Conditionally render Razorpay vs Stripe checkout button based on currency

```typescript
// Add import at top:
import { StripeCheckout } from "./stripe-checkout";

// Replace the <RazorpayCheckout> block (lines 67-75) with:
{currency === "INR" ? (
  <RazorpayCheckout
    planSlug={plan.slug}
    planName={plan.name}
    workspaceId={workspaceId}
    priceDisplay={`${symbol}${price}/mo`}
    disabled={isCurrent}
    variant={isCurrent ? "outline" : "default"}
    onSuccess={onSubscriptionChange}
  />
) : (
  <StripeCheckout
    planSlug={plan.slug}
    planName={plan.name}
    workspaceId={workspaceId}
    priceDisplay={`${symbol}${price}/mo`}
    disabled={isCurrent}
    variant={isCurrent ? "outline" : "default"}
    onSuccess={onSubscriptionChange}
  />
)}
```

**Step 5: Run tests**

Run: `npm run test -- __tests__/components/billing/stripe-checkout.test.tsx __tests__/components/billing/pricing-cards.test.tsx`
Expected: All PASS.

**Step 6: Commit**

```bash
git add components/billing/stripe-checkout.tsx components/billing/pricing-cards.tsx __tests__/components/billing/stripe-checkout.test.tsx
git commit -m "feat: add StripeCheckout component, show Razorpay for INR / Stripe for USD"
```

---

## Task 8: Update seed script for Stripe price sync

**Files:**
- Modify: `lib/db/seed-plans.ts`

**Step 1: Add Stripe sync function to seed script**

After the existing `syncToRazorpay` function (line 66), add:

```typescript
async function syncToStripe(planRecord: typeof plans.$inferSelect, planData: (typeof DEFAULT_PLANS)[number]) {
  if (!process.env.STRIPE_SECRET_KEY) {
    console.log("    Skipping Stripe sync (no credentials)");
    return;
  }
  if (planRecord.stripe_price_id) {
    console.log(`    Stripe price already exists: ${planRecord.stripe_price_id}`);
    return;
  }

  const Stripe = (await import("stripe")).default;
  const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

  // Create product
  const product = await stripe.products.create({
    name: `VoiceTask ${planData.name}`,
    description: `${planData.name} plan — $${planData.price_usd}/month`,
  });

  // Create price
  const price = await stripe.prices.create({
    product: product.id,
    unit_amount: planData.price_usd * 100, // cents
    currency: "usd",
    recurring: { interval: "month" },
  });

  await db.update(plans).set({ stripe_price_id: price.id }).where(eq(plans.id, planRecord.id));
  console.log(`    Synced to Stripe: ${price.id}`);
}
```

**Step 2: Call `syncToStripe` in the seed loop**

In the `seed()` function, after `await syncToRazorpay(existing, plan);` (line 84), add:

```typescript
await syncToStripe(existing, plan);
```

**Step 3: Commit**

```bash
git add lib/db/seed-plans.ts
git commit -m "feat: add Stripe product/price sync to plan seed script"
```

---

## Task 9: Add currency auto-detection to billing page

**Files:**
- Modify: `app/billing/page.tsx:31`

**Step 1: Auto-detect currency from browser locale**

In `app/billing/page.tsx`, change the initial currency state (line 31) from:

```typescript
const [currency, setCurrency] = useState<"INR" | "USD">("INR");
```

to:

```typescript
const [currency, setCurrency] = useState<"INR" | "USD">(() => {
  if (typeof navigator !== "undefined") {
    const locale = navigator.language || "";
    // Indian locales: en-IN, hi-IN, etc.
    if (locale.endsWith("-IN") || locale === "hi") return "INR";
  }
  return "USD";
});
```

**Step 2: Verify build**

Run: `npm run build`
Expected: Build succeeds.

**Step 3: Commit**

```bash
git add app/billing/page.tsx
git commit -m "feat: auto-detect INR/USD currency from browser locale"
```

---

## Task 10: Create email utility

**Files:**
- Create: `lib/email/index.ts`
- Create: `__tests__/lib/email/index.test.ts`

**Step 1: Write failing tests**

Create `__tests__/lib/email/index.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";

const mockSendMail = vi.fn();

vi.mock("nodemailer", () => ({
  default: {
    createTransport: vi.fn(() => ({
      sendMail: mockSendMail,
    })),
  },
}));

import { sendEmail } from "@/lib/email";

describe("sendEmail", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("sends email when SMTP env vars are configured", async () => {
    process.env.SMTP_HOST = "smtp.gmail.com";
    process.env.SMTP_PORT = "587";
    process.env.SMTP_USER = "test@gmail.com";
    process.env.SMTP_PASS = "password";
    process.env.SMTP_FROM = "VoiceTask <noreply@voicetask.com>";
    mockSendMail.mockResolvedValue({ messageId: "msg_123" });

    const result = await sendEmail({
      to: "user@example.com",
      subject: "Test Email",
      html: "<p>Hello</p>",
    });

    expect(result).toBe(true);
    expect(mockSendMail).toHaveBeenCalledWith({
      from: "VoiceTask <noreply@voicetask.com>",
      to: "user@example.com",
      subject: "Test Email",
      html: "<p>Hello</p>",
    });
  });

  it("returns false (no-op) when SMTP env vars are missing", async () => {
    delete process.env.SMTP_HOST;
    delete process.env.SMTP_USER;
    delete process.env.SMTP_PASS;

    const result = await sendEmail({
      to: "user@example.com",
      subject: "Test",
      html: "<p>Hi</p>",
    });

    expect(result).toBe(false);
    expect(mockSendMail).not.toHaveBeenCalled();
  });

  it("returns false when sendMail throws", async () => {
    process.env.SMTP_HOST = "smtp.gmail.com";
    process.env.SMTP_PORT = "587";
    process.env.SMTP_USER = "test@gmail.com";
    process.env.SMTP_PASS = "password";
    mockSendMail.mockRejectedValue(new Error("SMTP connection failed"));

    const result = await sendEmail({
      to: "user@example.com",
      subject: "Test",
      html: "<p>Hi</p>",
    });

    expect(result).toBe(false);
  });
});
```

**Step 2: Run tests — expect fail**

Run: `npm run test -- __tests__/lib/email/index.test.ts`

**Step 3: Create `lib/email/index.ts`**

```typescript
import nodemailer from "nodemailer";

interface SendEmailOptions {
  to: string;
  subject: string;
  html: string;
}

export async function sendEmail(opts: SendEmailOptions): Promise<boolean> {
  const host = process.env.SMTP_HOST;
  const user = process.env.SMTP_USER;
  const pass = process.env.SMTP_PASS;

  if (!host || !user || !pass) {
    console.log("Email skipped — SMTP not configured");
    return false;
  }

  try {
    const transporter = nodemailer.createTransport({
      host,
      port: Number(process.env.SMTP_PORT ?? "587"),
      secure: false,
      auth: { user, pass },
    });

    await transporter.sendMail({
      from: process.env.SMTP_FROM ?? `VoiceTask <${user}>`,
      to: opts.to,
      subject: opts.subject,
      html: opts.html,
    });

    return true;
  } catch (error) {
    console.error("Failed to send email:", error);
    return false;
  }
}
```

**Step 4: Run tests**

Run: `npm run test -- __tests__/lib/email/index.test.ts`
Expected: All PASS.

**Step 5: Commit**

```bash
git add lib/email/index.ts __tests__/lib/email/index.test.ts
git commit -m "feat: add email utility with Nodemailer, graceful no-op when SMTP not configured"
```

---

## Task 11: Create email templates

**Files:**
- Create: `lib/email/templates/invite.ts`
- Create: `lib/email/templates/trial-expiry.ts`
- Create: `lib/email/templates/welcome.ts`
- Create: `lib/email/templates/payment-receipt.ts`
- Create: `__tests__/lib/email/templates.test.ts`

**Step 1: Write failing tests**

Create `__tests__/lib/email/templates.test.ts`:

```typescript
import { describe, it, expect } from "vitest";
import { inviteEmailHtml } from "@/lib/email/templates/invite";
import { trialExpiryEmailHtml } from "@/lib/email/templates/trial-expiry";
import { welcomeEmailHtml } from "@/lib/email/templates/welcome";
import { paymentReceiptEmailHtml } from "@/lib/email/templates/payment-receipt";

describe("inviteEmailHtml", () => {
  it("renders with workspace name and accept link", () => {
    const html = inviteEmailHtml({
      workspaceName: "Acme Corp",
      inviterName: "Jane",
      acceptUrl: "http://localhost:3000/invite/abc123",
      role: "member",
    });
    expect(html).toContain("Acme Corp");
    expect(html).toContain("Jane");
    expect(html).toContain("http://localhost:3000/invite/abc123");
    expect(html).toContain("member");
  });
});

describe("trialExpiryEmailHtml", () => {
  it("renders with days remaining", () => {
    const html = trialExpiryEmailHtml({
      workspaceName: "Acme Corp",
      daysRemaining: 3,
      billingUrl: "http://localhost:3000/billing",
    });
    expect(html).toContain("3 days");
    expect(html).toContain("Acme Corp");
    expect(html).toContain("http://localhost:3000/billing");
  });

  it("renders expired state when 0 days", () => {
    const html = trialExpiryEmailHtml({
      workspaceName: "Acme Corp",
      daysRemaining: 0,
      billingUrl: "http://localhost:3000/billing",
    });
    expect(html).toContain("expired");
  });
});

describe("welcomeEmailHtml", () => {
  it("renders with user name", () => {
    const html = welcomeEmailHtml({
      userName: "John",
      loginUrl: "http://localhost:3000/login",
    });
    expect(html).toContain("John");
    expect(html).toContain("http://localhost:3000/login");
  });
});

describe("paymentReceiptEmailHtml", () => {
  it("renders with payment details", () => {
    const html = paymentReceiptEmailHtml({
      planName: "Team",
      amount: "$19.00",
      date: "Feb 20, 2026",
      billingUrl: "http://localhost:3000/billing",
    });
    expect(html).toContain("Team");
    expect(html).toContain("$19.00");
    expect(html).toContain("Feb 20, 2026");
  });
});
```

**Step 2: Run tests — expect fail**

Run: `npm run test -- __tests__/lib/email/templates.test.ts`

**Step 3: Create the 4 template files**

Create `lib/email/templates/invite.ts`:

```typescript
interface InviteEmailData {
  workspaceName: string;
  inviterName: string;
  acceptUrl: string;
  role: string;
}

export function inviteEmailHtml(data: InviteEmailData): string {
  return `
<!DOCTYPE html>
<html>
<body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
  <h2>You've been invited to ${data.workspaceName}</h2>
  <p>${data.inviterName} has invited you to join <strong>${data.workspaceName}</strong> as a <strong>${data.role}</strong>.</p>
  <p style="margin: 24px 0;">
    <a href="${data.acceptUrl}" style="background-color: #6366f1; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
      Accept Invitation
    </a>
  </p>
  <p style="color: #6b7280; font-size: 14px;">This invitation expires in 7 days. If you didn't expect this, you can safely ignore it.</p>
  <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 24px 0;" />
  <p style="color: #9ca3af; font-size: 12px;">VoiceTask — Project management with AI-powered voice capture</p>
</body>
</html>`.trim();
}
```

Create `lib/email/templates/trial-expiry.ts`:

```typescript
interface TrialExpiryEmailData {
  workspaceName: string;
  daysRemaining: number;
  billingUrl: string;
}

export function trialExpiryEmailHtml(data: TrialExpiryEmailData): string {
  const isExpired = data.daysRemaining <= 0;
  const headline = isExpired
    ? `Your trial for ${data.workspaceName} has expired`
    : `Your trial for ${data.workspaceName} ends in ${data.daysRemaining} days`;

  const message = isExpired
    ? "Your free trial has expired. Upgrade now to continue using all features."
    : `You have ${data.daysRemaining} days left on your free trial. Upgrade to keep access to all features.`;

  return `
<!DOCTYPE html>
<html>
<body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
  <h2>${headline}</h2>
  <p>${message}</p>
  <p style="margin: 24px 0;">
    <a href="${data.billingUrl}" style="background-color: #6366f1; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
      View Plans & Upgrade
    </a>
  </p>
  <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 24px 0;" />
  <p style="color: #9ca3af; font-size: 12px;">VoiceTask — Project management with AI-powered voice capture</p>
</body>
</html>`.trim();
}
```

Create `lib/email/templates/welcome.ts`:

```typescript
interface WelcomeEmailData {
  userName: string;
  loginUrl: string;
}

export function welcomeEmailHtml(data: WelcomeEmailData): string {
  return `
<!DOCTYPE html>
<html>
<body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
  <h2>Welcome to VoiceTask, ${data.userName}!</h2>
  <p>Your account is ready. You have a 14-day free trial with full access to all features.</p>
  <p>Here's what you can do:</p>
  <ul>
    <li>Create projects and track todos</li>
    <li>Log timesheet entries with voice capture</li>
    <li>Invite team members to collaborate</li>
  </ul>
  <p style="margin: 24px 0;">
    <a href="${data.loginUrl}" style="background-color: #6366f1; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
      Get Started
    </a>
  </p>
  <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 24px 0;" />
  <p style="color: #9ca3af; font-size: 12px;">VoiceTask — Project management with AI-powered voice capture</p>
</body>
</html>`.trim();
}
```

Create `lib/email/templates/payment-receipt.ts`:

```typescript
interface PaymentReceiptEmailData {
  planName: string;
  amount: string;
  date: string;
  billingUrl: string;
}

export function paymentReceiptEmailHtml(data: PaymentReceiptEmailData): string {
  return `
<!DOCTYPE html>
<html>
<body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
  <h2>Payment Receipt</h2>
  <p>Thank you for your payment! Here are the details:</p>
  <table style="border-collapse: collapse; width: 100%; margin: 16px 0;">
    <tr>
      <td style="padding: 8px; border-bottom: 1px solid #e5e7eb; color: #6b7280;">Plan</td>
      <td style="padding: 8px; border-bottom: 1px solid #e5e7eb; font-weight: 600;">${data.planName}</td>
    </tr>
    <tr>
      <td style="padding: 8px; border-bottom: 1px solid #e5e7eb; color: #6b7280;">Amount</td>
      <td style="padding: 8px; border-bottom: 1px solid #e5e7eb; font-weight: 600;">${data.amount}</td>
    </tr>
    <tr>
      <td style="padding: 8px; border-bottom: 1px solid #e5e7eb; color: #6b7280;">Date</td>
      <td style="padding: 8px; border-bottom: 1px solid #e5e7eb;">${data.date}</td>
    </tr>
  </table>
  <p style="margin: 24px 0;">
    <a href="${data.billingUrl}" style="background-color: #6366f1; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
      View Billing
    </a>
  </p>
  <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 24px 0;" />
  <p style="color: #9ca3af; font-size: 12px;">VoiceTask — Project management with AI-powered voice capture</p>
</body>
</html>`.trim();
}
```

**Step 4: Run tests**

Run: `npm run test -- __tests__/lib/email/templates.test.ts`
Expected: All PASS.

**Step 5: Commit**

```bash
git add lib/email/templates/ __tests__/lib/email/templates.test.ts
git commit -m "feat: add email templates for invite, trial-expiry, welcome, payment-receipt"
```

---

## Task 12: Wire invite emails into invitations.ts

**Files:**
- Modify: `lib/api/invitations.ts:55-65` (after creating invitation, send email)

**Step 1: Add email sending after invitation creation**

In `lib/api/invitations.ts`, after the `db.insert(workspaceInvitations).values(...)` block (line 63) and before `return { token }` (line 65), add:

```typescript
// Send invitation email (fire-and-forget)
import("@/lib/email").then(({ sendEmail }) =>
  import("@/lib/email/templates/invite").then(({ inviteEmailHtml }) => {
    const baseUrl = process.env.NEXTAUTH_URL ?? "http://localhost:3000";
    const acceptUrl = `${baseUrl}/invite/${token}`;

    // Get inviter name
    db.query.users.findFirst({ where: eq(users.id, actorId) }).then((inviter) => {
      const inviterName = inviter?.name || inviter?.email || "A teammate";

      // Get workspace name
      db.query.workspaces.findFirst({
        where: eq(workspaceInvitations.workspace_id, workspaceId),
      }).then(() => {
        // We don't have workspaces imported with the right alias, use a simpler approach
      });

      sendEmail({
        to: data.email,
        subject: `You've been invited to join a workspace on VoiceTask`,
        html: inviteEmailHtml({
          workspaceName: workspaceId, // We'll improve this
          inviterName,
          acceptUrl,
          role: data.role,
        }),
      });
    });
  })
).catch(() => {});
```

**Actually, a cleaner approach** — add the imports at top and send inline:

At the top of `lib/api/invitations.ts`, add:
```typescript
import { sendEmail } from "@/lib/email"
import { inviteEmailHtml } from "@/lib/email/templates/invite"
```

Then after `db.insert(workspaceInvitations).values(...)` (line 63), before `return { token }`:

```typescript
// Send invitation email (best-effort, don't block on failure)
const inviter = await db.query.users.findFirst({ where: eq(users.id, actorId) })
const inviterName = inviter?.name || inviter?.email || "A teammate"
const baseUrl = process.env.NEXTAUTH_URL ?? "http://localhost:3000"
const acceptUrl = `${baseUrl}/invite/${token}`

sendEmail({
  to: data.email,
  subject: `You've been invited to join a workspace on VoiceTask`,
  html: inviteEmailHtml({
    workspaceName: workspaceId,
    inviterName,
    acceptUrl,
    role: data.role,
  }),
}).catch(() => {})
```

Note: We pass `workspaceId` for now. To get the workspace name, we need to also look it up. Better approach — look up workspace name:

```typescript
const [inviter, workspace] = await Promise.all([
  db.query.users.findFirst({ where: eq(users.id, actorId) }),
  db.query.workspaces.findFirst({ where: eq(workspaces.id, workspaceId) }),
])
const inviterName = inviter?.name || inviter?.email || "A teammate"
const workspaceName = workspace?.name || "a workspace"
const baseUrl = process.env.NEXTAUTH_URL ?? "http://localhost:3000"
const acceptUrl = `${baseUrl}/invite/${token}`

sendEmail({
  to: data.email,
  subject: `You've been invited to join ${workspaceName} on VoiceTask`,
  html: inviteEmailHtml({
    workspaceName,
    inviterName,
    acceptUrl,
    role: data.role,
  }),
}).catch(() => {})
```

Also add `workspaces` to the import from schema (line 4):
```typescript
import { workspaceInvitations, workspaceMembers, users, workspaces } from "@/lib/db/schema"
```

**Step 2: Run existing tests to verify no regressions**

Run: `npm run test`
Expected: All existing tests PASS.

**Step 3: Commit**

```bash
git add lib/api/invitations.ts
git commit -m "feat: send invitation email when inviting a member"
```

---

## Task 13: Create trial expiry cron endpoint

**Files:**
- Create: `app/api/cron/trial-expiry/route.ts`
- Create: `__tests__/app/api/cron/trial-expiry.test.ts`

**Step 1: Write failing tests**

Create `__tests__/app/api/cron/trial-expiry.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";

vi.mock("@/lib/db", () => ({
  db: {
    query: {
      subscriptions: { findMany: vi.fn() },
    },
  },
}));

vi.mock("@/lib/db/schema", () => ({
  subscriptions: {},
  workspaces: {},
  users: {},
}));

vi.mock("@/lib/email", () => ({
  sendEmail: vi.fn().mockResolvedValue(true),
}));

vi.mock("@/lib/email/templates/trial-expiry", () => ({
  trialExpiryEmailHtml: vi.fn().mockReturnValue("<p>Trial expiry</p>"),
}));

import { db } from "@/lib/db";
import { sendEmail } from "@/lib/email";
import { GET } from "@/app/api/cron/trial-expiry/route";

describe("GET /api/cron/trial-expiry", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    process.env.CRON_SECRET = "test_cron_secret";
  });

  it("returns 401 when CRON_SECRET header is missing", async () => {
    const req = new Request("http://localhost/api/cron/trial-expiry");
    const res = await GET(req as any);
    expect(res.status).toBe(401);
  });

  it("returns 401 when CRON_SECRET header is wrong", async () => {
    const req = new Request("http://localhost/api/cron/trial-expiry", {
      headers: { "x-cron-secret": "wrong_secret" },
    });
    const res = await GET(req as any);
    expect(res.status).toBe(401);
  });

  it("returns 200 and processes trialing subscriptions", async () => {
    const trialEnd = new Date();
    trialEnd.setDate(trialEnd.getDate() + 3); // 3 days left

    vi.mocked(db.query.subscriptions.findMany).mockResolvedValue([
      {
        id: "sub_1",
        workspace_id: "ws_1",
        status: "trialing",
        trial_end: trialEnd,
        workspace: { id: "ws_1", name: "Acme", owner: { email: "owner@test.com" } },
      },
    ] as any);

    const req = new Request("http://localhost/api/cron/trial-expiry", {
      headers: { "x-cron-secret": "test_cron_secret" },
    });
    const res = await GET(req as any);
    expect(res.status).toBe(200);
    expect(sendEmail).toHaveBeenCalled();
  });

  it("skips subscriptions with more than 4 days remaining", async () => {
    const trialEnd = new Date();
    trialEnd.setDate(trialEnd.getDate() + 10); // 10 days left

    vi.mocked(db.query.subscriptions.findMany).mockResolvedValue([
      {
        id: "sub_1",
        workspace_id: "ws_1",
        status: "trialing",
        trial_end: trialEnd,
        workspace: { id: "ws_1", name: "Acme", owner: { email: "owner@test.com" } },
      },
    ] as any);

    const req = new Request("http://localhost/api/cron/trial-expiry", {
      headers: { "x-cron-secret": "test_cron_secret" },
    });
    const res = await GET(req as any);
    expect(res.status).toBe(200);
    expect(sendEmail).not.toHaveBeenCalled();
  });
});
```

**Step 2: Run tests — expect fail**

Run: `npm run test -- __tests__/app/api/cron/trial-expiry.test.ts`

**Step 3: Create `app/api/cron/trial-expiry/route.ts`**

```typescript
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";
import { subscriptions } from "@/lib/db/schema";
import { eq } from "drizzle-orm";
import { sendEmail } from "@/lib/email";
import { trialExpiryEmailHtml } from "@/lib/email/templates/trial-expiry";

// Warning thresholds: send emails when trial has 4, 2, 1, or 0 days remaining
const WARNING_DAYS = [4, 2, 1, 0];

export async function GET(req: NextRequest) {
  // Verify cron secret
  const secret = req.headers.get("x-cron-secret");
  const expectedSecret = process.env.CRON_SECRET;

  if (!expectedSecret || secret !== expectedSecret) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    // Find all trialing subscriptions with their workspace and owner
    const trialingSubs = await db.query.subscriptions.findMany({
      where: eq(subscriptions.status, "trialing"),
      with: {
        workspace: {
          with: {
            owner: true,
          },
        },
      },
    });

    let emailsSent = 0;

    for (const sub of trialingSubs) {
      if (!sub.trial_end) continue;

      const daysRemaining = Math.ceil(
        (new Date(sub.trial_end).getTime() - Date.now()) / (1000 * 60 * 60 * 24)
      );

      // Only send on specific warning days
      if (!WARNING_DAYS.includes(daysRemaining)) continue;

      const workspace = sub.workspace as any;
      const ownerEmail = workspace?.owner?.email;
      if (!ownerEmail) continue;

      const baseUrl = process.env.NEXTAUTH_URL ?? "http://localhost:3000";

      await sendEmail({
        to: ownerEmail,
        subject: daysRemaining <= 0
          ? `Your VoiceTask trial has expired`
          : `Your VoiceTask trial expires in ${daysRemaining} day${daysRemaining === 1 ? "" : "s"}`,
        html: trialExpiryEmailHtml({
          workspaceName: workspace.name,
          daysRemaining: Math.max(0, daysRemaining),
          billingUrl: `${baseUrl}/billing`,
        }),
      });

      emailsSent++;
    }

    return NextResponse.json({
      status: "ok",
      processed: trialingSubs.length,
      emailsSent,
    });
  } catch (error) {
    console.error("Trial expiry cron error:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
```

**Step 4: Run tests**

Run: `npm run test -- __tests__/app/api/cron/trial-expiry.test.ts`
Expected: All PASS.

**Step 5: Commit**

```bash
git add app/api/cron/trial-expiry/route.ts __tests__/app/api/cron/trial-expiry.test.ts
git commit -m "feat: add trial expiry cron endpoint with email warnings"
```

---

## Task 14: Full test suite + build verification

**Files:** None (verification only)

**Step 1: Run full test suite**

Run: `npm run test`
Expected: All tests pass.

**Step 2: Run coverage report**

Run: `npm run test:coverage`
Expected: Coverage report generated. Review that new code has reasonable coverage.

**Step 3: Run production build**

Run: `npm run build`
Expected: Build succeeds with no type errors.

**Step 4: Update vitest.config.ts coverage includes**

If needed, update `vitest.config.ts` to include new directories in coverage:

```typescript
coverage: {
  provider: "v8",
  reporter: ["text", "text-summary", "lcov"],
  include: ["lib/api/**", "lib/payments/**", "lib/email/**", "components/billing/**"],
},
```

**Step 5: Final commit**

```bash
git add vitest.config.ts
git commit -m "chore: update vitest coverage config for Sprint 1.3 modules"
```

---

## Summary

| Task | Description | Files |
|------|-------------|-------|
| 1 | Install deps | package.json |
| 2 | Schema: stripe_price_id + stripe_customer_id | lib/db/schema.ts, test-helpers |
| 3 | Stripe client library | lib/payments/stripe.ts + tests |
| 4 | Stripe create-checkout route | app/api/payments/stripe/create-checkout + tests |
| 5 | Stripe webhook route | app/api/payments/stripe/webhook + tests |
| 6 | Billing success/cancel pages | app/billing/success, app/billing/cancel |
| 7 | StripeCheckout component + update PricingCards | components/billing/ + tests |
| 8 | Seed script: Stripe sync | lib/db/seed-plans.ts |
| 9 | Currency auto-detection | app/billing/page.tsx |
| 10 | Email utility | lib/email/index.ts + tests |
| 11 | Email templates (4) | lib/email/templates/ + tests |
| 12 | Wire invite emails | lib/api/invitations.ts |
| 13 | Trial expiry cron | app/api/cron/trial-expiry + tests |
| 14 | Full test suite + build verification | vitest.config.ts |
