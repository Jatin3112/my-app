# Sprint 5.2 — Recurring Tasks + Data Export + Onboarding Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add recurring todos (daily/weekly/monthly), GDPR-compliant data export, and a first-login onboarding checklist.

**Architecture:** Recurring todos use schema columns on the existing `todos` table with occurrence generation triggered synchronously in `toggleTodoComplete()`. Data export is a single JSON download via authenticated API route. Onboarding state is stored as JSON on the `users` table and displayed as a dashboard card.

**Tech Stack:** Drizzle ORM, Next.js API routes, date-fns for date arithmetic, existing shadcn/ui components

---

### Task 1: Add recurrence columns to todos schema

**Files:**
- Modify: `lib/db/schema.ts` (todos table definition, ~line 27-43)

**Step 1: Add three columns to the `todos` table**

In `lib/db/schema.ts`, add these columns to the `todos` pgTable definition, after `due_date`:

```ts
recurrence_rule: text("recurrence_rule"), // "daily" | "weekly" | "monthly" | null
recurrence_end_date: text("recurrence_end_date"), // ISO date string or null
parent_todo_id: uuid("parent_todo_id"), // self-referencing, no FK constraint needed
```

Note: We skip the FK constraint on `parent_todo_id` to avoid circular reference issues. The column is just used for grouping/display.

**Step 2: Run migrations**

```bash
npm run db:generate
npm run db:push
```

**Step 3: Commit**

```bash
git add lib/db/schema.ts drizzle/
git commit -m "feat: add recurrence columns to todos schema"
```

---

### Task 2: Create recurrence logic with tests

**Files:**
- Create: `lib/api/recurrence.ts`
- Create: `__tests__/lib/api/recurrence.test.ts`

**Step 1: Write the tests**

Create `__tests__/lib/api/recurrence.test.ts`:

```ts
import { describe, it, expect } from "vitest"
import { getNextDueDate, shouldGenerateNextOccurrence } from "@/lib/api/recurrence"

describe("getNextDueDate", () => {
  it("adds 1 day for daily", () => {
    expect(getNextDueDate("2026-02-15", "daily")).toBe("2026-02-16")
  })

  it("adds 7 days for weekly", () => {
    expect(getNextDueDate("2026-02-15", "weekly")).toBe("2026-02-22")
  })

  it("adds 1 month for monthly", () => {
    expect(getNextDueDate("2026-01-31", "monthly")).toBe("2026-02-28")
  })

  it("handles year boundary", () => {
    expect(getNextDueDate("2026-12-28", "weekly")).toBe("2027-01-04")
  })
})

describe("shouldGenerateNextOccurrence", () => {
  it("returns true when no end date", () => {
    expect(shouldGenerateNextOccurrence("2026-03-01", null)).toBe(true)
  })

  it("returns true when next date is before end date", () => {
    expect(shouldGenerateNextOccurrence("2026-03-01", "2026-12-31")).toBe(true)
  })

  it("returns true when next date equals end date", () => {
    expect(shouldGenerateNextOccurrence("2026-03-01", "2026-03-01")).toBe(true)
  })

  it("returns false when next date is after end date", () => {
    expect(shouldGenerateNextOccurrence("2026-04-01", "2026-03-31")).toBe(false)
  })
})
```

**Step 2: Run tests to verify they fail**

```bash
npx vitest run __tests__/lib/api/recurrence.test.ts
```

Expected: FAIL (module not found)

**Step 3: Write the implementation**

Create `lib/api/recurrence.ts`:

```ts
import { addDays, addWeeks, addMonths, format, parseISO } from "date-fns"

export function getNextDueDate(currentDueDate: string, rule: string): string {
  const date = parseISO(currentDueDate)
  switch (rule) {
    case "daily":
      return format(addDays(date, 1), "yyyy-MM-dd")
    case "weekly":
      return format(addWeeks(date, 1), "yyyy-MM-dd")
    case "monthly":
      return format(addMonths(date, 1), "yyyy-MM-dd")
    default:
      return currentDueDate
  }
}

export function shouldGenerateNextOccurrence(
  nextDueDate: string,
  endDate: string | null,
): boolean {
  if (!endDate) return true
  return nextDueDate <= endDate
}
```

**Step 4: Run tests to verify they pass**

```bash
npx vitest run __tests__/lib/api/recurrence.test.ts
```

Expected: PASS (all 6 tests)

**Step 5: Commit**

```bash
git add lib/api/recurrence.ts __tests__/lib/api/recurrence.test.ts
git commit -m "feat: add recurrence date logic with tests"
```

---

### Task 3: Wire recurrence into toggleTodoComplete

**Files:**
- Modify: `lib/api/todos.ts` (~line 67-88, `toggleTodoComplete` function)
- Modify: `__tests__/lib/api/todos.test.ts` (add recurrence test cases)

**Step 1: Add recurrence tests to the existing test file**

Add to `__tests__/lib/api/todos.test.ts`:

```ts
// At the top, add the mock for recurrence
vi.mock("@/lib/api/recurrence", () => ({
  getNextDueDate: vi.fn().mockReturnValue("2026-02-22"),
  shouldGenerateNextOccurrence: vi.fn().mockReturnValue(true),
}))

// Add new test cases in the toggleTodoComplete describe block:
describe("toggleTodoComplete with recurrence", () => {
  it("creates next occurrence when completing a recurring todo", async () => {
    const recurringTodo = {
      id: "t1", user_id: "u1", workspace_id: "w1",
      title: "Weekly report", completed: false,
      recurrence_rule: "weekly", due_date: "2026-02-15",
      recurrence_end_date: null, parent_todo_id: null,
      description: "Send report", project_id: "p1", priority: "medium",
      sort_order: 0, created_at: new Date(), updated_at: new Date(),
    }
    // Mock findFirst to return the recurring todo
    vi.mocked(db.query.todos.findFirst).mockResolvedValue(recurringTodo as any)
    // Mock update chain
    const mockReturning = vi.fn().mockResolvedValue([{ ...recurringTodo, completed: true }])
    const mockWhere = vi.fn().mockReturnValue({ returning: mockReturning })
    const mockSet = vi.fn().mockReturnValue({ where: mockWhere })
    vi.mocked(db.update).mockReturnValue({ set: mockSet } as any)
    // Mock insert for the new occurrence
    const mockInsertReturning = vi.fn().mockResolvedValue([{ ...recurringTodo, id: "t2" }])
    const mockInsertValues = vi.fn().mockReturnValue({ returning: mockInsertReturning })
    vi.mocked(db.insert).mockReturnValue({ values: mockInsertValues } as any)

    await toggleTodoComplete("w1", "u1", "t1", true)

    expect(db.insert).toHaveBeenCalled()
  })
})
```

**Step 2: Modify `toggleTodoComplete` in `lib/api/todos.ts`**

Add the import at the top:

```ts
import { getNextDueDate, shouldGenerateNextOccurrence } from "@/lib/api/recurrence"
```

After the notification block (line ~84), add recurrence generation:

```ts
  // Generate next occurrence for recurring todos
  if (completed && existing.recurrence_rule && existing.due_date) {
    const nextDueDate = getNextDueDate(existing.due_date, existing.recurrence_rule)
    if (shouldGenerateNextOccurrence(nextDueDate, existing.recurrence_end_date)) {
      await db.insert(todos).values({
        user_id: existing.user_id,
        workspace_id: existing.workspace_id,
        title: existing.title,
        description: existing.description,
        project_id: existing.project_id,
        priority: existing.priority,
        due_date: nextDueDate,
        recurrence_rule: existing.recurrence_rule,
        recurrence_end_date: existing.recurrence_end_date,
        parent_todo_id: existing.parent_todo_id || existing.id,
        completed: false,
        sort_order: existing.sort_order,
      } as any).returning()
    }
  }
```

**Step 3: Run tests**

```bash
npx vitest run __tests__/lib/api/todos.test.ts
```

**Step 4: Commit**

```bash
git add lib/api/todos.ts __tests__/lib/api/todos.test.ts
git commit -m "feat: generate next occurrence on recurring todo completion"
```

---

### Task 4: Add recurrence UI to todo create/edit form

**Files:**
- Modify: `components/todos/todo-list.tsx`

**Step 1: Update formData state to include recurrence fields**

In `todo-list.tsx`, find the `formData` state (~line 251) and add:

```ts
const [formData, setFormData] = useState({
  title: "",
  description: "",
  project_id: "none",
  priority: "none",
  due_date: "",
  recurrence_rule: "",       // ADD
  recurrence_end_date: "",   // ADD
})
```

Update ALL places where `setFormData` resets the form (3 places: ~line 266, 482, 607) to include the new fields:

```ts
setFormData({ title: "", description: "", project_id: "none", priority: "none", due_date: "", recurrence_rule: "", recurrence_end_date: "" })
```

**Step 2: Update `handleEdit` to load recurrence fields**

In `handleEdit` (~line 467), add:

```ts
function handleEdit(todo: Todo) {
  setEditingTodo(todo)
  setFormData({
    title: todo.title,
    description: todo.description || "",
    project_id: todo.project_id || "none",
    priority: todo.priority || "none",
    due_date: todo.due_date || "",
    recurrence_rule: todo.recurrence_rule || "",           // ADD
    recurrence_end_date: todo.recurrence_end_date || "",   // ADD
  })
  setIsOpen(true)
}
```

**Step 3: Update `handleSubmit` to pass recurrence fields**

In `handleSubmit` (~line 361), update the todoData:

```ts
const todoData = {
  ...formData,
  project_id: formData.project_id === "none" ? null : formData.project_id,
  due_date: formData.due_date || null,
  recurrence_rule: formData.recurrence_rule || null,             // ADD
  recurrence_end_date: formData.recurrence_end_date || null,     // ADD
}
```

**Step 4: Add recurrence selector to the form dialog**

After the due date picker in the form (find the due_date `DatePicker` section), add:

```tsx
<div className="grid gap-2">
  <Label>Repeat</Label>
  <Select
    value={formData.recurrence_rule}
    onValueChange={(value) => setFormData({ ...formData, recurrence_rule: value })}
  >
    <SelectTrigger className="w-full">
      <SelectValue placeholder="No repeat" />
    </SelectTrigger>
    <SelectContent>
      <SelectItem value="">None</SelectItem>
      <SelectItem value="daily">Daily</SelectItem>
      <SelectItem value="weekly">Weekly</SelectItem>
      <SelectItem value="monthly">Monthly</SelectItem>
    </SelectContent>
  </Select>
</div>
{formData.recurrence_rule && (
  <div className="grid gap-2">
    <Label>Repeat until (optional)</Label>
    <DatePicker
      value={formData.recurrence_end_date}
      onChange={(date) => setFormData({ ...formData, recurrence_end_date: date })}
      placeholder="No end date"
    />
  </div>
)}
```

**Step 5: Add repeat icon to todo rows**

Import `Repeat` from lucide-react. In the `SortableRow` component, next to the priority badge or due date display, add:

```tsx
{todo.recurrence_rule && (
  <Repeat className="w-3.5 h-3.5 text-muted-foreground" title={`Repeats ${todo.recurrence_rule}`} />
)}
```

**Step 6: Update handleToggleComplete to reload after recurrence generation**

In `handleToggleComplete` (~line 384), after the `toggleTodoComplete` call succeeds, reload the list to show the new occurrence:

```ts
const handleToggleComplete = useCallback(async (todo: Todo) => {
  setTodos((prev) =>
    prev.map((t) => (t.id === todo.id ? { ...t, completed: !t.completed } : t))
  )
  try {
    await toggleTodoComplete(workspaceId!, userId, todo.id, !todo.completed)
    // Reload to show new occurrence if recurring
    if (todo.recurrence_rule && !todo.completed) {
      await loadTodos()
    }
  } catch (error) {
    setTodos((prev) =>
      prev.map((t) => (t.id === todo.id ? { ...t, completed: todo.completed } : t))
    )
    toast.error("Failed to update todo")
    console.error(error)
  }
}, [workspaceId, userId])
```

**Step 7: Commit**

```bash
git add components/todos/todo-list.tsx
git commit -m "feat: add recurrence UI to todo create/edit form"
```

---

### Task 5: Write recurrence component tests

**Files:**
- Modify: `__tests__/components/todos/todo-list.test.tsx`

**Step 1: Add test cases for recurrence UI**

Add these test cases:

```ts
it("shows recurrence selector in the create form", async () => {
  // Open create dialog, verify "Repeat" label and selector exist
})

it("shows repeat icon on recurring todos", () => {
  // Render with a todo that has recurrence_rule: "weekly"
  // Assert the Repeat icon is displayed
})
```

**Step 2: Run tests**

```bash
npx vitest run __tests__/components/todos/todo-list.test.tsx
```

**Step 3: Commit**

```bash
git add __tests__/components/todos/todo-list.test.tsx
git commit -m "test: add recurrence UI tests"
```

---

### Task 6: Add onboarding column to users schema

**Files:**
- Modify: `lib/db/schema.ts` (users table, ~line 4-13)

**Step 1: Add `onboarding` JSON column to `users` table**

After the `updated_at` column:

```ts
onboarding: json("onboarding").$type<{
  created_project?: boolean
  added_todo?: boolean
  tried_voice?: boolean
  invited_member?: boolean
  dismissed?: boolean
}>().default({}),
```

**Step 2: Run migrations**

```bash
npm run db:generate
npm run db:push
```

**Step 3: Commit**

```bash
git add lib/db/schema.ts drizzle/
git commit -m "feat: add onboarding JSON column to users table"
```

---

### Task 7: Create onboarding server actions with tests

**Files:**
- Create: `lib/api/onboarding.ts`
- Create: `__tests__/lib/api/onboarding.test.ts`

**Step 1: Write the tests**

Create `__tests__/lib/api/onboarding.test.ts`:

```ts
import { describe, it, expect, vi, beforeEach } from "vitest"

vi.mock("@/lib/db", () => ({
  db: {
    query: { users: { findFirst: vi.fn() } },
    update: vi.fn(),
  },
}))

vi.mock("@/lib/db/schema", () => ({
  users: { id: "id", onboarding: "onboarding" },
}))

import { getOnboardingStatus, updateOnboardingStep, dismissOnboarding } from "@/lib/api/onboarding"
import { db } from "@/lib/db"

beforeEach(() => {
  vi.clearAllMocks()
})

describe("getOnboardingStatus", () => {
  it("returns default status for new user", async () => {
    vi.mocked(db.query.users.findFirst).mockResolvedValue({
      onboarding: {},
    } as any)

    const status = await getOnboardingStatus("u1")
    expect(status.completed).toBe(0)
    expect(status.total).toBe(4)
    expect(status.dismissed).toBe(false)
  })

  it("counts completed steps", async () => {
    vi.mocked(db.query.users.findFirst).mockResolvedValue({
      onboarding: { created_project: true, added_todo: true },
    } as any)

    const status = await getOnboardingStatus("u1")
    expect(status.completed).toBe(2)
  })

  it("detects dismissed state", async () => {
    vi.mocked(db.query.users.findFirst).mockResolvedValue({
      onboarding: { dismissed: true },
    } as any)

    const status = await getOnboardingStatus("u1")
    expect(status.dismissed).toBe(true)
  })
})

describe("updateOnboardingStep", () => {
  it("updates a specific step", async () => {
    vi.mocked(db.query.users.findFirst).mockResolvedValue({
      onboarding: {},
    } as any)
    const mockWhere = vi.fn().mockResolvedValue(undefined)
    const mockSet = vi.fn().mockReturnValue({ where: mockWhere })
    vi.mocked(db.update).mockReturnValue({ set: mockSet } as any)

    await updateOnboardingStep("u1", "created_project")
    expect(db.update).toHaveBeenCalled()
  })
})

describe("dismissOnboarding", () => {
  it("sets dismissed to true", async () => {
    vi.mocked(db.query.users.findFirst).mockResolvedValue({
      onboarding: { created_project: true },
    } as any)
    const mockWhere = vi.fn().mockResolvedValue(undefined)
    const mockSet = vi.fn().mockReturnValue({ where: mockWhere })
    vi.mocked(db.update).mockReturnValue({ set: mockSet } as any)

    await dismissOnboarding("u1")
    expect(db.update).toHaveBeenCalled()
  })
})
```

**Step 2: Write the implementation**

Create `lib/api/onboarding.ts`:

```ts
"use server"

import { db } from "@/lib/db"
import { users } from "@/lib/db/schema"
import { eq } from "drizzle-orm"

type OnboardingStep = "created_project" | "added_todo" | "tried_voice" | "invited_member"

const ALL_STEPS: OnboardingStep[] = ["created_project", "added_todo", "tried_voice", "invited_member"]

type OnboardingData = {
  created_project?: boolean
  added_todo?: boolean
  tried_voice?: boolean
  invited_member?: boolean
  dismissed?: boolean
}

export type OnboardingStatus = {
  steps: Record<OnboardingStep, boolean>
  completed: number
  total: number
  dismissed: boolean
  allDone: boolean
}

export async function getOnboardingStatus(userId: string): Promise<OnboardingStatus> {
  const user = await db.query.users.findFirst({
    where: eq(users.id, userId),
    columns: { onboarding: true },
  })

  const data = (user?.onboarding as OnboardingData) || {}

  const steps = ALL_STEPS.reduce((acc, step) => {
    acc[step] = !!data[step]
    return acc
  }, {} as Record<OnboardingStep, boolean>)

  const completed = ALL_STEPS.filter((s) => steps[s]).length

  return {
    steps,
    completed,
    total: ALL_STEPS.length,
    dismissed: !!data.dismissed,
    allDone: completed === ALL_STEPS.length,
  }
}

export async function updateOnboardingStep(userId: string, step: OnboardingStep): Promise<void> {
  const user = await db.query.users.findFirst({
    where: eq(users.id, userId),
    columns: { onboarding: true },
  })

  const current = (user?.onboarding as OnboardingData) || {}
  await db.update(users)
    .set({ onboarding: { ...current, [step]: true } })
    .where(eq(users.id, userId))
}

export async function dismissOnboarding(userId: string): Promise<void> {
  const user = await db.query.users.findFirst({
    where: eq(users.id, userId),
    columns: { onboarding: true },
  })

  const current = (user?.onboarding as OnboardingData) || {}
  await db.update(users)
    .set({ onboarding: { ...current, dismissed: true } })
    .where(eq(users.id, userId))
}
```

**Step 3: Run tests**

```bash
npx vitest run __tests__/lib/api/onboarding.test.ts
```

**Step 4: Commit**

```bash
git add lib/api/onboarding.ts __tests__/lib/api/onboarding.test.ts
git commit -m "feat: add onboarding server actions with tests"
```

---

### Task 8: Create onboarding checklist UI component

**Files:**
- Create: `components/dashboard/onboarding-checklist.tsx`

**Step 1: Create the component**

```tsx
"use client"

import { useState } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Progress } from "@/components/ui/progress"
import { CheckCircle2, Circle, X, FolderPlus, ListTodo, Mic, UserPlus } from "lucide-react"
import { dismissOnboarding, type OnboardingStatus } from "@/lib/api/onboarding"
import { toast } from "sonner"

const STEPS = [
  { key: "created_project" as const, label: "Create a project", icon: FolderPlus, href: "/todos" },
  { key: "added_todo" as const, label: "Add a todo", icon: ListTodo, href: "/todos" },
  { key: "tried_voice" as const, label: "Try voice capture", icon: Mic, href: "/todos" },
  { key: "invited_member" as const, label: "Invite a team member", icon: UserPlus, href: "/workspace/settings" },
]

export function OnboardingChecklist({
  status,
  userId,
}: {
  status: OnboardingStatus
  userId: string
}) {
  const [dismissed, setDismissed] = useState(false)

  if (dismissed || status.dismissed || status.allDone) return null

  async function handleDismiss() {
    setDismissed(true)
    try {
      await dismissOnboarding(userId)
    } catch {
      toast.error("Failed to dismiss")
      setDismissed(false)
    }
  }

  const progress = (status.completed / status.total) * 100

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between pb-2">
        <CardTitle className="text-lg">Getting Started</CardTitle>
        <Button variant="ghost" size="icon" className="h-8 w-8" onClick={handleDismiss}>
          <X className="h-4 w-4" />
        </Button>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="space-y-1">
          <div className="flex items-center justify-between text-sm">
            <span className="text-muted-foreground">{status.completed} of {status.total} complete</span>
            <span className="font-medium">{Math.round(progress)}%</span>
          </div>
          <Progress value={progress} className="h-2" />
        </div>
        <div className="space-y-2">
          {STEPS.map((step) => {
            const done = status.steps[step.key]
            const Icon = step.icon
            return (
              <a
                key={step.key}
                href={step.href}
                className={`flex items-center gap-3 rounded-lg px-3 py-2 text-sm transition-colors ${
                  done
                    ? "text-muted-foreground line-through"
                    : "hover:bg-muted"
                }`}
              >
                {done ? (
                  <CheckCircle2 className="h-4 w-4 text-green-500 shrink-0" />
                ) : (
                  <Circle className="h-4 w-4 text-muted-foreground shrink-0" />
                )}
                <Icon className="h-4 w-4 shrink-0" />
                {step.label}
              </a>
            )
          })}
        </div>
      </CardContent>
    </Card>
  )
}
```

**Step 2: Verify the progress component exists**

```bash
ls components/ui/progress.tsx
```

If it doesn't exist, add it:

```bash
npx shadcn@latest add progress
```

**Step 3: Commit**

```bash
git add components/dashboard/onboarding-checklist.tsx
git commit -m "feat: add onboarding checklist component"
```

---

### Task 9: Wire onboarding into dashboard

**Files:**
- Modify: `lib/api/loaders.ts` (add onboarding to dashboard data)
- Modify: `app/(app)/dashboard/page.tsx`

**Step 1: Add onboarding status to `loadDashboardData`**

In `lib/api/loaders.ts`, import and call `getOnboardingStatus`:

```ts
import { getOnboardingStatus, type OnboardingStatus } from "@/lib/api/onboarding"
```

Add `onboarding` to the `DashboardData` type:

```ts
onboarding?: OnboardingStatus
```

At the end of `loadDashboardData`, fetch onboarding and include it in the return:

```ts
const onboarding = await getOnboardingStatus(userId)
return { stats, ..., onboarding }
```

**Step 2: Add OnboardingChecklist to dashboard page**

In `app/(app)/dashboard/page.tsx`, import and render:

```tsx
import { OnboardingChecklist } from "@/components/dashboard/onboarding-checklist"
```

After the greeting and before KeyMetrics, add:

```tsx
{data?.onboarding && (
  <OnboardingChecklist status={data.onboarding} userId={userId} />
)}
```

**Step 3: Commit**

```bash
git add lib/api/loaders.ts app/(app)/dashboard/page.tsx
git commit -m "feat: wire onboarding checklist into dashboard"
```

---

### Task 10: Auto-update onboarding on key actions

**Files:**
- Modify: `lib/api/todos.ts` (createTodo — mark `added_todo`)
- Modify: `lib/api/projects.ts` or wherever `createProject` lives (mark `created_project`)
- Modify: `lib/api/invitations.ts` or wherever invite logic lives (mark `invited_member`)
- Modify: `components/quick-capture.tsx` (mark `tried_voice` after voice input)

**Step 1: Add onboarding update to `createTodo`**

In `lib/api/todos.ts`, import and call:

```ts
import { updateOnboardingStep } from "@/lib/api/onboarding"
```

At the end of `createTodo`, after the notification:

```ts
await updateOnboardingStep(userId, "added_todo").catch(() => {})
```

**Step 2: Add onboarding update to `createProject`**

Find the `createProject` function and add:

```ts
await updateOnboardingStep(userId, "created_project").catch(() => {})
```

**Step 3: Add onboarding update to invite logic**

Find the invite/add-member function and add:

```ts
await updateOnboardingStep(userId, "invited_member").catch(() => {})
```

**Step 4: Add onboarding update to voice capture**

In `components/quick-capture.tsx`, when voice input produces a result, call the server action:

```ts
import { updateOnboardingStep } from "@/lib/api/onboarding"
// After voice result is received:
await updateOnboardingStep(userId, "tried_voice").catch(() => {})
```

Note: `updateOnboardingStep` is a server action (`"use server"`), so it can be called from client components.

**Step 5: Commit**

```bash
git add lib/api/todos.ts lib/api/projects.ts lib/api/invitations.ts components/quick-capture.tsx
git commit -m "feat: auto-update onboarding steps on key actions"
```

---

### Task 11: Create GDPR data export API route

**Files:**
- Create: `app/api/export/data/route.ts`

**Step 1: Create the export route**

```ts
import { NextRequest, NextResponse } from "next/server"
import { getServerSession } from "next-auth"
import { authOptions } from "@/lib/auth/auth-options"
import { db } from "@/lib/db"
import { users, todos, timesheetEntries, comments, workspaceMembers, attachments, notificationPreferences } from "@/lib/db/schema"
import { eq } from "drizzle-orm"

export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions)
  if (!session?.user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
  }

  const userId = (session.user as any).id

  try {
    const [user, userTodos, userTimesheet, userComments, memberships, userAttachments, notifPrefs] =
      await Promise.all([
        db.query.users.findFirst({
          where: eq(users.id, userId),
          columns: { id: true, email: true, name: true, created_at: true },
        }),
        db.select().from(todos).where(eq(todos.user_id, userId)),
        db.select().from(timesheetEntries).where(eq(timesheetEntries.user_id, userId)),
        db.select().from(comments).where(eq(comments.user_id, userId)),
        db.select().from(workspaceMembers).where(eq(workspaceMembers.user_id, userId)),
        db.select().from(attachments).where(eq(attachments.user_id, userId)),
        db.select().from(notificationPreferences).where(eq(notificationPreferences.user_id, userId)),
      ])

    const exportData = {
      exported_at: new Date().toISOString(),
      user,
      todos: userTodos,
      timesheet_entries: userTimesheet,
      comments: userComments,
      workspace_memberships: memberships,
      attachments: userAttachments,
      notification_preferences: notifPrefs,
    }

    const json = JSON.stringify(exportData, null, 2)

    return new NextResponse(json, {
      headers: {
        "Content-Type": "application/json",
        "Content-Disposition": `attachment; filename="voicetask-data-export-${new Date().toISOString().split("T")[0]}.json"`,
      },
    })
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}
```

**Step 2: Commit**

```bash
git add app/api/export/data/route.ts
git commit -m "feat: add GDPR data export API route"
```

---

### Task 12: Add "Export My Data" button to workspace settings

**Files:**
- Modify: `app/(app)/workspace/settings/page.tsx`

**Step 1: Add export button**

Add a new Card section at the bottom of the settings page, before the danger zone:

```tsx
<Card>
  <CardHeader>
    <CardTitle>Your Data</CardTitle>
    <CardDescription>Download all your data as a JSON file (GDPR compliance).</CardDescription>
  </CardHeader>
  <CardContent>
    <Button
      variant="outline"
      onClick={async () => {
        try {
          const response = await fetch("/api/export/data")
          if (!response.ok) throw new Error("Export failed")
          const blob = await response.blob()
          const url = URL.createObjectURL(blob)
          const a = document.createElement("a")
          a.href = url
          a.download = `voicetask-data-export-${new Date().toISOString().split("T")[0]}.json`
          document.body.appendChild(a)
          a.click()
          document.body.removeChild(a)
          URL.revokeObjectURL(url)
          toast.success("Data exported successfully")
        } catch {
          toast.error("Failed to export data")
        }
      }}
    >
      <Download className="w-4 h-4 mr-2" />
      Export My Data
    </Button>
  </CardContent>
</Card>
```

Import `Download` from `lucide-react` and `CardDescription` from the card component.

**Step 2: Commit**

```bash
git add app/(app)/workspace/settings/page.tsx
git commit -m "feat: add Export My Data button to workspace settings"
```

---

### Task 13: Write tests for data export and onboarding component

**Files:**
- Create: `__tests__/components/dashboard/onboarding-checklist.test.tsx`

**Step 1: Write onboarding component tests**

```ts
import { describe, it, expect, vi } from "vitest"
import { render, screen, fireEvent } from "@testing-library/react"

vi.mock("@/lib/api/onboarding", () => ({
  dismissOnboarding: vi.fn().mockResolvedValue(undefined),
}))

vi.mock("sonner", () => ({
  toast: { error: vi.fn(), success: vi.fn() },
}))

import { OnboardingChecklist } from "@/components/dashboard/onboarding-checklist"
import type { OnboardingStatus } from "@/lib/api/onboarding"

const baseStatus: OnboardingStatus = {
  steps: { created_project: false, added_todo: false, tried_voice: false, invited_member: false },
  completed: 0,
  total: 4,
  dismissed: false,
  allDone: false,
}

describe("OnboardingChecklist", () => {
  it("renders all 4 steps", () => {
    render(<OnboardingChecklist status={baseStatus} userId="u1" />)
    expect(screen.getByText("Create a project")).toBeInTheDocument()
    expect(screen.getByText("Add a todo")).toBeInTheDocument()
    expect(screen.getByText("Try voice capture")).toBeInTheDocument()
    expect(screen.getByText("Invite a team member")).toBeInTheDocument()
  })

  it("shows progress count", () => {
    const status = { ...baseStatus, completed: 2 }
    render(<OnboardingChecklist status={status} userId="u1" />)
    expect(screen.getByText("2 of 4 complete")).toBeInTheDocument()
  })

  it("hides when all done", () => {
    const status = { ...baseStatus, allDone: true, completed: 4 }
    const { container } = render(<OnboardingChecklist status={status} userId="u1" />)
    expect(container.innerHTML).toBe("")
  })

  it("hides when dismissed", () => {
    const status = { ...baseStatus, dismissed: true }
    const { container } = render(<OnboardingChecklist status={status} userId="u1" />)
    expect(container.innerHTML).toBe("")
  })

  it("dismisses on X click", async () => {
    render(<OnboardingChecklist status={baseStatus} userId="u1" />)
    const dismissBtn = screen.getByRole("button")
    fireEvent.click(dismissBtn)
    // Component should hide after dismiss
  })
})
```

**Step 2: Run tests**

```bash
npx vitest run __tests__/components/dashboard/onboarding-checklist.test.tsx
```

**Step 3: Commit**

```bash
git add __tests__/components/dashboard/onboarding-checklist.test.tsx
git commit -m "test: add onboarding checklist component tests"
```

---

### Task 14: Run full test suite + build verification, update CLAUDE.md

**Step 1: Run full test suite**

```bash
npm run test
```

Expected: All tests pass (310+ tests)

**Step 2: Run build**

```bash
npm run build
```

Expected: Build succeeds

**Step 3: Update CLAUDE.md**

Mark all Sprint 5.2 tasks as `[x]` and update the progress tracker:

```
| 5. Export | 5.2 Recurring + GDPR | DONE | 14/14 |
```

Update total: `153/180`

**Step 4: Commit**

```bash
git add CLAUDE.md
git commit -m "docs: mark Sprint 5.2 complete in CLAUDE.md (14/14 tasks)"
```

---
