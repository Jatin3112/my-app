# Sprint 6.1 — Infrastructure + Monitoring Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add rate limiting, CSRF protection, admin dashboard, error tracking (Sentry), analytics (PostHog), and Vercel deployment config.

**Architecture:** Rate limiting uses in-memory sliding window (no Redis). CSRF uses origin-header validation. Admin dashboard is an email-whitelisted route group with server actions for stats/workspace management. Sentry and PostHog are placeholder integrations that no-op when env vars are missing.

**Tech Stack:** Next.js middleware, Drizzle ORM queries, @sentry/nextjs, posthog-js, shadcn/ui table/cards

---

### Task 1: Create rate limiting utility with tests

**Files:**
- Create: `lib/api/rate-limit.ts`
- Create: `__tests__/lib/api/rate-limit.test.ts`

**Step 1: Write the tests**

Create `__tests__/lib/api/rate-limit.test.ts`:

```ts
import { describe, it, expect, vi, beforeEach } from "vitest"
import { rateLimit, resetRateLimits } from "@/lib/api/rate-limit"

beforeEach(() => {
  resetRateLimits()
})

describe("rateLimit", () => {
  it("allows requests under the limit", () => {
    const result = rateLimit("test-key", 5, 60000)
    expect(result.success).toBe(true)
    expect(result.remaining).toBe(4)
  })

  it("blocks requests over the limit", () => {
    for (let i = 0; i < 5; i++) {
      rateLimit("block-key", 5, 60000)
    }
    const result = rateLimit("block-key", 5, 60000)
    expect(result.success).toBe(false)
    expect(result.remaining).toBe(0)
  })

  it("tracks different keys independently", () => {
    for (let i = 0; i < 5; i++) {
      rateLimit("key-a", 5, 60000)
    }
    const result = rateLimit("key-b", 5, 60000)
    expect(result.success).toBe(true)
  })

  it("resets after window expires", () => {
    vi.useFakeTimers()
    for (let i = 0; i < 5; i++) {
      rateLimit("expire-key", 5, 1000)
    }
    expect(rateLimit("expire-key", 5, 1000).success).toBe(false)

    vi.advanceTimersByTime(1001)
    expect(rateLimit("expire-key", 5, 1000).success).toBe(true)
    vi.useRealTimers()
  })

  it("returns resetAt timestamp", () => {
    const result = rateLimit("reset-key", 5, 60000)
    expect(result.resetAt).toBeGreaterThan(Date.now())
  })
})
```

**Step 2: Run tests to verify they fail**

```bash
npx vitest run __tests__/lib/api/rate-limit.test.ts
```

Expected: FAIL (module not found)

**Step 3: Write the implementation**

Create `lib/api/rate-limit.ts`:

```ts
const store = new Map<string, number[]>()

export function rateLimit(
  key: string,
  maxRequests: number,
  windowMs: number,
): { success: boolean; remaining: number; resetAt: number } {
  const now = Date.now()
  const windowStart = now - windowMs

  const timestamps = store.get(key) || []
  const recent = timestamps.filter((t) => t > windowStart)

  if (recent.length >= maxRequests) {
    store.set(key, recent)
    return {
      success: false,
      remaining: 0,
      resetAt: recent[0] + windowMs,
    }
  }

  recent.push(now)
  store.set(key, recent)

  return {
    success: true,
    remaining: maxRequests - recent.length,
    resetAt: recent[0] + windowMs,
  }
}

export function resetRateLimits(): void {
  store.clear()
}
```

**Step 4: Run tests**

```bash
npx vitest run __tests__/lib/api/rate-limit.test.ts
```

Expected: PASS (all 5 tests)

**Step 5: Commit**

```bash
git add lib/api/rate-limit.ts __tests__/lib/api/rate-limit.test.ts
git commit -m "feat: add in-memory rate limiting utility with tests"
```

---

### Task 2: Apply rate limiting to auth endpoints

**Files:**
- Modify: `app/api/auth/register/route.ts`
- Modify: `app/api/auth/[...nextauth]/route.ts`

**Step 1: Add rate limiting to register endpoint**

In `app/api/auth/register/route.ts`, add at the top of the `POST` handler, before any other logic:

```ts
import { rateLimit } from "@/lib/api/rate-limit"

// Inside POST handler, first lines:
const ip = req.headers.get("x-forwarded-for") || "unknown"
const { success, remaining, resetAt } = rateLimit(`register:${ip}`, 3, 60000)
if (!success) {
  return NextResponse.json(
    { error: "Too many requests. Please try again later." },
    {
      status: 429,
      headers: { "Retry-After": String(Math.ceil((resetAt - Date.now()) / 1000)) },
    },
  )
}
```

**Step 2: Add rate limiting to NextAuth login endpoint**

In `app/api/auth/[...nextauth]/route.ts`, wrap the handler with rate limiting for POST (login):

```ts
import { NextRequest, NextResponse } from "next/server"
import NextAuth from "next-auth"
import { authOptions } from "@/lib/auth/auth-options"
import { rateLimit } from "@/lib/api/rate-limit"

const handler = NextAuth(authOptions)

export { handler as GET }

export async function POST(req: NextRequest, context: any) {
  const ip = req.headers.get("x-forwarded-for") || "unknown"
  const { success, resetAt } = rateLimit(`login:${ip}`, 5, 60000)
  if (!success) {
    return NextResponse.json(
      { error: "Too many login attempts. Please try again later." },
      {
        status: 429,
        headers: { "Retry-After": String(Math.ceil((resetAt - Date.now()) / 1000)) },
      },
    )
  }
  return handler(req, context)
}
```

**Step 3: Commit**

```bash
git add app/api/auth/register/route.ts "app/api/auth/[...nextauth]/route.ts"
git commit -m "feat: add rate limiting to login and register endpoints"
```

---

### Task 3: Create CSRF protection utility

**Files:**
- Create: `lib/api/csrf.ts`
- Create: `__tests__/lib/api/csrf.test.ts`

**Step 1: Write the tests**

Create `__tests__/lib/api/csrf.test.ts`:

```ts
import { describe, it, expect, vi, beforeEach } from "vitest"

// Save and mock env
const originalEnv = process.env.NEXTAUTH_URL

beforeEach(() => {
  process.env.NEXTAUTH_URL = "http://localhost:3000"
})

import { validateOrigin } from "@/lib/api/csrf"

describe("validateOrigin", () => {
  it("allows requests with matching origin", () => {
    const headers = new Headers({ Origin: "http://localhost:3000" })
    expect(validateOrigin(headers)).toBe(true)
  })

  it("blocks requests with mismatched origin", () => {
    const headers = new Headers({ Origin: "http://evil.com" })
    expect(validateOrigin(headers)).toBe(false)
  })

  it("allows requests with no origin (same-origin navigation)", () => {
    const headers = new Headers()
    expect(validateOrigin(headers)).toBe(true)
  })

  it("falls back to referer when origin is missing", () => {
    const headers = new Headers({ Referer: "http://localhost:3000/some-page" })
    expect(validateOrigin(headers)).toBe(true)
  })

  it("blocks mismatched referer", () => {
    const headers = new Headers({ Referer: "http://evil.com/attack" })
    expect(validateOrigin(headers)).toBe(false)
  })
})
```

**Step 2: Write the implementation**

Create `lib/api/csrf.ts`:

```ts
export function validateOrigin(headers: Headers): boolean {
  const allowedOrigin = process.env.NEXTAUTH_URL || "http://localhost:3000"
  const allowedHost = new URL(allowedOrigin).host

  const origin = headers.get("origin")
  if (origin) {
    try {
      return new URL(origin).host === allowedHost
    } catch {
      return false
    }
  }

  const referer = headers.get("referer")
  if (referer) {
    try {
      return new URL(referer).host === allowedHost
    } catch {
      return false
    }
  }

  // No origin or referer — same-origin requests (e.g. form submits, server actions)
  return true
}
```

**Step 3: Run tests**

```bash
npx vitest run __tests__/lib/api/csrf.test.ts
```

**Step 4: Commit**

```bash
git add lib/api/csrf.ts __tests__/lib/api/csrf.test.ts
git commit -m "feat: add CSRF origin validation utility with tests"
```

---

### Task 4: Apply CSRF protection to sensitive API routes

**Files:**
- Modify: `app/api/upload/route.ts`
- Modify: `app/api/export/data/route.ts`

**Step 1: Add CSRF check to upload route**

In `app/api/upload/route.ts`, add at the top of the POST handler:

```ts
import { validateOrigin } from "@/lib/api/csrf"

// First line of POST handler:
if (!validateOrigin(request.headers)) {
  return NextResponse.json({ error: "Invalid origin" }, { status: 403 })
}
```

**Step 2: Add CSRF check to data export route**

In `app/api/export/data/route.ts`, add at the top of the GET handler:

```ts
import { validateOrigin } from "@/lib/api/csrf"

// First line of GET handler:
if (!validateOrigin(request.headers)) {
  return NextResponse.json({ error: "Invalid origin" }, { status: 403 })
}
```

**Step 3: Commit**

```bash
git add app/api/upload/route.ts app/api/export/data/route.ts
git commit -m "feat: add CSRF protection to upload and export endpoints"
```

---

### Task 5: Create admin server actions with tests

**Files:**
- Create: `lib/api/admin.ts`
- Create: `__tests__/lib/api/admin.test.ts`

**Step 1: Write the tests**

Create `__tests__/lib/api/admin.test.ts`:

```ts
import { describe, it, expect, vi, beforeEach } from "vitest"

vi.mock("@/lib/db", () => ({
  db: {
    select: vi.fn(),
    update: vi.fn(),
    query: {
      users: { findMany: vi.fn() },
      workspaces: { findMany: vi.fn() },
    },
  },
}))

vi.mock("@/lib/db/schema", () => ({
  users: { id: "id" },
  workspaces: { id: "id" },
  workspaceMembers: { workspace_id: "workspace_id" },
  subscriptions: { id: "id", workspace_id: "workspace_id", plan_id: "plan_id", trial_end: "trial_end" },
  plans: { price_inr: "price_inr" },
}))

import { isAdmin, getAdminStats } from "@/lib/api/admin"
import { db } from "@/lib/db"

beforeEach(() => {
  vi.clearAllMocks()
})

describe("isAdmin", () => {
  it("returns true for whitelisted email", () => {
    process.env.ADMIN_EMAILS = "admin@test.com,boss@test.com"
    expect(isAdmin("admin@test.com")).toBe(true)
  })

  it("returns false for non-whitelisted email", () => {
    process.env.ADMIN_EMAILS = "admin@test.com"
    expect(isAdmin("hacker@test.com")).toBe(false)
  })

  it("returns false when ADMIN_EMAILS not set", () => {
    delete process.env.ADMIN_EMAILS
    expect(isAdmin("admin@test.com")).toBe(false)
  })
})

describe("getAdminStats", () => {
  it("returns stats object", async () => {
    // Mock count queries
    const mockFrom = vi.fn().mockResolvedValue([{ count: 10 }])
    vi.mocked(db.select).mockReturnValue({ from: mockFrom } as any)

    const stats = await getAdminStats()
    expect(stats).toHaveProperty("totalUsers")
    expect(stats).toHaveProperty("totalWorkspaces")
  })
})
```

**Step 2: Write the implementation**

Create `lib/api/admin.ts`:

```ts
"use server"

import { db } from "@/lib/db"
import { users, workspaces, workspaceMembers, subscriptions, plans } from "@/lib/db/schema"
import { eq, count, sum, and } from "drizzle-orm"

export function isAdmin(email: string): boolean {
  const adminEmails = process.env.ADMIN_EMAILS
  if (!adminEmails) return false
  return adminEmails.split(",").map((e) => e.trim()).includes(email)
}

export async function getAdminStats() {
  const [userCount, workspaceCount, activeTrials, activeSubscriptions] = await Promise.all([
    db.select({ count: count() }).from(users),
    db.select({ count: count() }).from(workspaces),
    db.select({ count: count() }).from(subscriptions).where(eq(subscriptions.status, "trialing")),
    db.select({ count: count() }).from(subscriptions).where(eq(subscriptions.status, "active")),
  ])

  return {
    totalUsers: userCount[0].count,
    totalWorkspaces: workspaceCount[0].count,
    activeTrials: activeTrials[0].count,
    activeSubscriptions: activeSubscriptions[0].count,
  }
}

export async function getWorkspaceList() {
  const result = await db
    .select({
      id: workspaces.id,
      name: workspaces.name,
      slug: workspaces.slug,
      owner_id: workspaces.owner_id,
      created_at: workspaces.created_at,
    })
    .from(workspaces)
    .orderBy(workspaces.created_at)

  const enriched = await Promise.all(
    result.map(async (ws) => {
      const [memberCount, sub] = await Promise.all([
        db.select({ count: count() }).from(workspaceMembers).where(eq(workspaceMembers.workspace_id, ws.id)),
        db.query.subscriptions.findFirst({
          where: eq(subscriptions.workspace_id, ws.id),
          with: { plan: true },
          orderBy: (s, { desc }) => [desc(s.created_at)],
        }),
      ])
      return {
        ...ws,
        memberCount: memberCount[0].count,
        planName: sub?.plan?.name || "None",
        status: sub?.status || "none",
        trialEnd: sub?.trial_end,
      }
    }),
  )

  return enriched
}

export async function extendTrial(workspaceId: string, days: number) {
  const sub = await db.query.subscriptions.findFirst({
    where: eq(subscriptions.workspace_id, workspaceId),
    orderBy: (s, { desc }) => [desc(s.created_at)],
  })
  if (!sub) throw new Error("No subscription found")

  const newEnd = new Date(sub.trial_end || new Date())
  newEnd.setDate(newEnd.getDate() + days)

  await db.update(subscriptions)
    .set({ trial_end: newEnd, status: "trialing", updated_at: new Date() })
    .where(eq(subscriptions.id, sub.id))

  return { success: true, newTrialEnd: newEnd }
}

export async function changeWorkspacePlan(workspaceId: string, planId: string) {
  const sub = await db.query.subscriptions.findFirst({
    where: eq(subscriptions.workspace_id, workspaceId),
    orderBy: (s, { desc }) => [desc(s.created_at)],
  })
  if (!sub) throw new Error("No subscription found")

  await db.update(subscriptions)
    .set({ plan_id: planId, updated_at: new Date() })
    .where(eq(subscriptions.id, sub.id))

  return { success: true }
}
```

**Step 3: Run tests**

```bash
npx vitest run __tests__/lib/api/admin.test.ts
```

**Step 4: Commit**

```bash
git add lib/api/admin.ts __tests__/lib/api/admin.test.ts
git commit -m "feat: add admin server actions with tests"
```

---

### Task 6: Create admin dashboard layout and page

**Files:**
- Create: `app/(admin)/admin/layout.tsx`
- Create: `app/(admin)/admin/page.tsx`

**Step 1: Create admin layout with auth + whitelist guard**

Create `app/(admin)/admin/layout.tsx`:

```tsx
import { getServerSession } from "next-auth"
import { authOptions } from "@/lib/auth/auth-options"
import { redirect } from "next/navigation"
import { isAdmin } from "@/lib/api/admin"

export default async function AdminLayout({ children }: { children: React.ReactNode }) {
  const session = await getServerSession(authOptions)
  if (!session?.user?.email) redirect("/login")
  if (!isAdmin(session.user.email)) redirect("/dashboard")

  return (
    <div className="min-h-screen bg-background">
      <header className="border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="container flex h-14 items-center px-4">
          <h1 className="text-lg font-semibold">VoiceTask Admin</h1>
          <span className="ml-auto text-sm text-muted-foreground">{session.user.email}</span>
        </div>
      </header>
      <main className="container px-4 py-6">{children}</main>
    </div>
  )
}
```

**Step 2: Create admin dashboard page**

Create `app/(admin)/admin/page.tsx`:

```tsx
import { getAdminStats, getWorkspaceList } from "@/lib/api/admin"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Users, Building2, CreditCard, Clock } from "lucide-react"

export default async function AdminPage() {
  const [stats, workspaces] = await Promise.all([
    getAdminStats(),
    getWorkspaceList(),
  ])

  return (
    <div className="space-y-6">
      <h2 className="text-2xl font-bold">Dashboard</h2>

      <div className="grid gap-4 md:grid-cols-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Total Users</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.totalUsers}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Workspaces</CardTitle>
            <Building2 className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.totalWorkspaces}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Active Trials</CardTitle>
            <Clock className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.activeTrials}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Active Subscriptions</CardTitle>
            <CreditCard className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.activeSubscriptions}</div>
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>All Workspaces</CardTitle>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Name</TableHead>
                <TableHead>Plan</TableHead>
                <TableHead>Members</TableHead>
                <TableHead>Status</TableHead>
                <TableHead>Created</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {workspaces.map((ws) => (
                <TableRow key={ws.id}>
                  <TableCell className="font-medium">{ws.name}</TableCell>
                  <TableCell>{ws.planName}</TableCell>
                  <TableCell>{ws.memberCount}</TableCell>
                  <TableCell>
                    <span className={`inline-flex items-center rounded-full px-2 py-1 text-xs font-medium ${
                      ws.status === "active" ? "bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300" :
                      ws.status === "trialing" ? "bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300" :
                      "bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300"
                    }`}>
                      {ws.status}
                    </span>
                  </TableCell>
                  <TableCell>{new Date(ws.created_at).toLocaleDateString()}</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  )
}
```

**Step 3: Add `/admin` to middleware matcher**

In `middleware.ts`, add `"/admin/:path*"` to the matcher array.

**Step 4: Commit**

```bash
git add "app/(admin)/admin/layout.tsx" "app/(admin)/admin/page.tsx" middleware.ts
git commit -m "feat: add admin dashboard with stats and workspace list"
```

---

### Task 7: Create Sentry placeholder integration

**Files:**
- Create: `sentry.client.config.ts`
- Create: `sentry.server.config.ts`
- Modify: `next.config.ts`

**Step 1: Install Sentry**

```bash
npm install @sentry/nextjs
```

**Step 2: Create client config**

Create `sentry.client.config.ts` at project root:

```ts
import * as Sentry from "@sentry/nextjs"

if (process.env.NEXT_PUBLIC_SENTRY_DSN) {
  Sentry.init({
    dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
    tracesSampleRate: 0.1,
    replaysSessionSampleRate: 0,
    replaysOnErrorSampleRate: 1.0,
  })
}
```

**Step 3: Create server config**

Create `sentry.server.config.ts` at project root:

```ts
import * as Sentry from "@sentry/nextjs"

if (process.env.SENTRY_DSN) {
  Sentry.init({
    dsn: process.env.SENTRY_DSN,
    tracesSampleRate: 0.1,
  })
}
```

**Step 4: Wrap next.config.ts with Sentry**

Update `next.config.ts`:

```ts
import type { NextConfig } from "next";
import { withSentryConfig } from "@sentry/nextjs";

const nextConfig: NextConfig = {
  images: {
    formats: ["image/avif", "image/webp"],
  },
};

export default process.env.SENTRY_DSN || process.env.NEXT_PUBLIC_SENTRY_DSN
  ? withSentryConfig(nextConfig, {
      silent: true,
      org: process.env.SENTRY_ORG,
      project: process.env.SENTRY_PROJECT,
    })
  : nextConfig;
```

**Step 5: Commit**

```bash
git add sentry.client.config.ts sentry.server.config.ts next.config.ts package.json package-lock.json
git commit -m "feat: add Sentry error tracking placeholder integration"
```

---

### Task 8: Create PostHog analytics wrapper

**Files:**
- Create: `lib/analytics.ts`
- Create: `__tests__/lib/analytics.test.ts`

**Step 1: Install PostHog**

```bash
npm install posthog-js
```

**Step 2: Write the tests**

Create `__tests__/lib/analytics.test.ts`:

```ts
import { describe, it, expect, vi, beforeEach } from "vitest"

// Mock posthog-js
vi.mock("posthog-js", () => ({
  default: {
    init: vi.fn(),
    capture: vi.fn(),
    identify: vi.fn(),
  },
}))

beforeEach(() => {
  vi.clearAllMocks()
  delete process.env.NEXT_PUBLIC_POSTHOG_KEY
})

import { trackEvent, identifyUser, initAnalytics } from "@/lib/analytics"

describe("analytics", () => {
  it("no-ops trackEvent when PostHog key is not set", () => {
    expect(() => trackEvent("test_event", {})).not.toThrow()
  })

  it("no-ops identifyUser when PostHog key is not set", () => {
    expect(() => identifyUser("u1", { email: "a@b.com" })).not.toThrow()
  })
})
```

**Step 3: Write the implementation**

Create `lib/analytics.ts`:

```ts
import posthog from "posthog-js"

let initialized = false

export function initAnalytics(): void {
  if (initialized) return
  const key = process.env.NEXT_PUBLIC_POSTHOG_KEY
  if (!key) return

  posthog.init(key, {
    api_host: process.env.NEXT_PUBLIC_POSTHOG_HOST || "https://us.i.posthog.com",
    capture_pageview: false,
  })
  initialized = true
}

export function trackEvent(name: string, properties?: Record<string, any>): void {
  if (!process.env.NEXT_PUBLIC_POSTHOG_KEY) return
  initAnalytics()
  posthog.capture(name, properties)
}

export function identifyUser(userId: string, traits?: Record<string, any>): void {
  if (!process.env.NEXT_PUBLIC_POSTHOG_KEY) return
  initAnalytics()
  posthog.identify(userId, traits)
}
```

**Step 4: Run tests**

```bash
npx vitest run __tests__/lib/analytics.test.ts
```

**Step 5: Commit**

```bash
git add lib/analytics.ts __tests__/lib/analytics.test.ts package.json package-lock.json
git commit -m "feat: add PostHog analytics wrapper with graceful no-op"
```

---

### Task 9: Create Neon migration guide in database config

**Files:**
- Modify: `lib/db/index.ts` (add comment with Neon instructions)

**Step 1: Update db config with production-ready comments**

The file already handles Neon (ssl, prepare flags). Just add a comment block:

```ts
// Production setup (Neon):
// 1. Create database at https://neon.tech
// 2. Set DATABASE_URL in Vercel env vars to your Neon connection string
// 3. The config below auto-detects remote vs localhost and adjusts SSL + pooling
```

**Step 2: Commit**

```bash
git add lib/db/index.ts
git commit -m "docs: add Neon migration instructions to db config"
```

---

### Task 10: Create Vercel deployment config

**Files:**
- Create: `vercel.json`

**Step 1: Create vercel.json**

```json
{
  "crons": [
    {
      "path": "/api/cron/trial-expiry",
      "schedule": "0 8 * * *"
    }
  ]
}
```

**Step 2: Commit**

```bash
git add vercel.json
git commit -m "feat: add Vercel deployment config with cron schedule"
```

---

### Task 11: Write admin dashboard tests

**Files:**
- Create: `__tests__/lib/api/admin.test.ts` (already created in Task 5, extend if needed)

The admin tests were already created in Task 5. This task is for additional integration/component testing if needed.

**Step 1: Verify admin tests pass**

```bash
npx vitest run __tests__/lib/api/admin.test.ts
```

**Step 2: Commit if changes needed**

```bash
git add __tests__/lib/api/admin.test.ts
git commit -m "test: extend admin dashboard tests"
```

---

### Task 12: Run full test suite + build verification, update CLAUDE.md

**Step 1: Run full test suite**

```bash
npm run test
```

Expected: All tests pass (340+ tests)

**Step 2: Run build**

```bash
npm run build
```

Expected: Build succeeds

**Step 3: Fix any issues**

If build or tests fail, debug and fix.

**Step 4: Update CLAUDE.md**

Mark all Sprint 6.1 tasks as `[x]` and update the progress tracker:

```
| 6. Production | 6.1 Infra + Monitoring | DONE | 14/14 |
```

Update total: `167/180`

**Step 5: Commit**

```bash
git add CLAUDE.md
git commit -m "docs: mark Sprint 6.1 complete in CLAUDE.md (14/14 tasks)"
```

---
